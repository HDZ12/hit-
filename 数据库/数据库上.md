# 1
1. 关于数据库系统和数据库管理系统，下列说法正确的是(**C**)

A.数据库系统和数据库管理系统指的是同一软件产品

B.数据库系统和数据库管理系统指的是不同软件产品

C.数据库管理系统是软件产品，而数据库系统不仅仅是软件产品

D.数据库系统是软件产品，而数据库管理系统不仅仅是软件产品

---
1. 关于数据库系统，下列说法正确的是(**D**)

A.数据库系统的构成包括计算机网铬基本系统、数据库和数据库管理系统

B.数据库系统的构成包括计算机网铬基本系统、数据库、数据库管理系统和数据库应
用程序

C.数据库系统的构成包括计算机网络基本系统、数据库、数据库应用程序和数据库管
理员

D.数据库系统的构城包括数据库、数据库管理系统、数据库应用程序、数据库管理员以
及计算机与网络基本系统

---
1. 从系统角度看数据库管理系统，其功能包括(**D**)

A.数据库语言及其编译

B.查询实现与查询优化

C.事务处理

D.不仅仅有(A)(B)(C)功能，还包括其他功能

---
1. 从系统角度看数据库管理系统，其功能包括(**D**)

A.X查询实现与查询优化

B.Y事务处理

C.Z数据存储与索引

D.不仅仅包含X、Y、Z功能，还包括其他功能

---
1. 下列那些功能不是数据库管理系统的功能(**D**)

A.完整性控制

B.并发控制

C.通讯控制

D.处理机控制

---
1. 关于数据库系统语言，下列说法正确的是(**B**)

A.数据库系统语言包括了DDL和DML

B.数据库系统语言包括了DDL、DML和DCL

C.数据库系统语言包括了DDL、DML和C++/Jaa

D.数据库系统语言包括了DDL、DML和程序设计语言

---
1. 关于DDL,下列说法正确的是(**A**)

A.DDL是数据库定义语言

B.DDL是数据库操纵语言

C.DDL是数据库控制语言

D.DDL是数据库维护语言

---
1. 关于DML,下列说法正确的是(**B**)

A.DML是数据库定义语言

B.DML是数据库操纵语言

C.DML是数据库控制语言

D.DML是数据库维护语言

---
1. 从用户角度看数据库管理系统，其功能包括(**D**)

A.数据库定义

B.数据库操纵

C.数据库控制

D.上述全部

---
1. 从用户角度看数据库管理系统，其功能包括(**ABCD**)

A.数据库定义

B.数据库操纵

C,数据库控制

D.数据库维护
## 2
1. 数据库系统的三级模式是指（**D**）

A.用户模式、局部模式和全局模式

B.外模式、概念模式和逻辑模式

C.外模式、内模式和存储模式

D.用户模式、概念模式和存储模式

---
1. 在三级模式两层映像结构中，“模式”是指(**D**)

A.外模式

B.内模式

C.存储模式

D.概念模式

---
1. 在三级模式两层映像结构中，“物理模式”是指(**D**)

A.外模式

B.全局模式

C.用户模式

D.存储模式

---
1. 在三级模式两层映像结构中，“全局模式”是指(**D**)

A.外模式

B.用户模式

C.内模式

D.概念模式

---
1. 在三级模式两层映像结构中，“局部模式”是指(**D**)

A.既念模式

B.内模式

C.逻辑模式

D.外模式

---
1. 关于三级模式，下列说法不正确的是(**D**)

A.概念模式又称为全局模式

B.概念模式又称为逻辑模式

C.内模式又称为存储模式

D.内模式又称为局部模式

---
1. 关于数据独立性，下列说法正确的为(**C**)

A.外模式到概念模式的映像实现了数据的物理独立性

B.外模式到内模式的映像实现了数据的物理独立性

C.概念模式到内模式的映像实现了数据的物理独立性

D.以上说法均不正确

---
1. 关于数据独立性，下列说法正确的为(**A**)

A.外模式到概念模式的映像实现了数据的逻辑独立性

B.外模式到内模式的映像实现了数据的逻辑独立性

C.概念模式到内模式的映像实现了数据的逻辑独立性

D.以上说法均不正确

---
1. 数据库系统的数据独立性是指(**B**)

A.不会因为数据的变化而影响应用程序

B.不会因为系统数据存储结构与数据逻辑结构的变化而影响应用程序

C.不会因为存储策略的变化而影响存储结构

D.不会因为某些存储结构的变化而影响其他的存储结构

---
1. 下列说法不正确的是(**D**)

A.模式是对数据的抽象，数据的结构性描述你为模式

B.数据模型是对模式的抽象，模式的结构性描述称为数据模型

C.一个数据库是由一系列模式及其数据构成的

D.模式是对数据模型的抽象，数据模型的结构性描述称为模式

---
1. 第一代数据库系统是指(**D**)

A.文件系统

B.基于XML模型的数据库系统

C.基于关系模型的数据库系统

D.基于网状模型或层次模型的数据库系统

---
1. 第二代数据库系统是指(**D**)

A.基于文件的数据库系统：

B.基于XML模型的数据库系统

C.基于网状模型或层次模型的数据库系统

D.基于关系模型的数据库系统

---
1. 数据库系统与文件系统的主要差别在(**D**)

A.数据的组织是否依赖于具体的应用程序

B.数据存取是否可以记录或记录的集合为单位进行操作

C.不同文件之间以及不同记录之间是否有联系

D.包括其他全部选项

---
1. 关系数据库系统对层次网状数据库系统的重大改进是(**D**)

A.消除了由用户建立指针的弊端

B.将逐一记录的操作改进为支持记录集合的操作

C.数据检索操作不依赖于路径信息或过程信息，即非过程化的操作

D.包括其他全都选项

---
1. 关系数据库系统对层次网状数据库系统的重大改进是(**D**)

A.消除了由用户建立指针的弊端

B.将逐一记录的操作改进为支持记录集合的操作

C.数据检索操作不依赖于路径信息或过程信息，即非过程化的操作

D.包括其他全都选项

---
1. 面向对象数据库系统对关系数据库系统的重大改进是(**D**)

A.允许复杂的数据类型存在

B.突破了关系模型第一范式的限制

C.既支持记录集合的操作，又支持面向对象的操作

D.包括其他全部选项
## 3
1. 某关系R的外键是指(**A**)

A.其它关系的候选键，可以是R中的主属性或非主属性

B.该关系除主键之外的另一个候选键

C.其它关系的候选键，同时作为R的主属性

D.其它关系的候选键，同时作为R的非主属性

---
1. 关系模型中，下列关于候选键说法正确的是(**A**)

A.可由其值能惟一标识该关系中任何元组的一个或多个属性组成

B.可由多个任意属性组成

C.至多由其值能惟一标识该关系任何元组的一个属性组成

D.其余都不是

---

1. 若某属性非该关系的主键，却是另外一个关系的主键，则该属性称为(**A**)

A.外键

B.主键

C.候选键

D.其余者都不是

---
1. 下列四项中说法正确的是(**A**)

A.关系的任何属性都是不可再分的

B.R(A1,A2,...,An),这种描述又被称为关系模式，其中Ai是指属性所对应的域

C.关系模式和关系都是不随时间变化的

D.同一关系模式下关系是唯一的


---
1. 假设有关系R(A,B,C),其主码为A;关系S(D,A),其主码为D,外码为A。如下图
示：

| R   |     |     |     | S   |      |     |
| --- | --- | --- | --- | --- | ---- | --- |
| A   | B   | C   |     | D   | A    |     |
| 1   | 2   | 3   |     | 1   | 2    |     |
| 2   | 1   | 3   |     | 2   | NULL |     |
|     |     |     |     | 3   | 3    |     |
|     |     |     |     |     |      |     |
|     |     |     |     | 4   | 1    |     |


则关系S中违反完整性规则的元组是(**A**)

A.<3,3>

B.<1.2>

C.<2,null>

D.<4.1>

---
1. 有关系R(A:int,B:int,C:int,)主码为A,没有违反完整性规则的选项是(**D**)

A.

|   |   |   |
|---|---|---|
|A|B|C|
|1|2|3|
|1|3|5|

B.

|      |     |     |
| ---- | --- | --- |
| A    | B   | C   |
| 1    | 2   | 3   |
| null | 1   | 3   |

C. 

|     |     |     |
| --- | --- | --- |
| A   | B   | C   |
| 1   | 2   | 3   |
| 2   | 2.1 | 3   |

D.

|     |     |      |
| --- | --- | ---- |
| A   | B   | C    |
| 1   | 2   | 3    |
| 2   | 1   | null |


---
1. 已知三个域：男人={李基，张鹏}，女人={王方，刘玉}，子女={李键，张睿，张
峰}。这一组域（男人，女人，子女）的笛卡尔积的基数为(**A**)

A.12

B.9

C.7

D.27

---
1. 现有如下关系：患者（患者编号，患者姓名，性别，出生日期），医疗（患者编
号，患者姓名，医生编号，医生姓名，诊断日期)。其中，“医疗”关系中的外键
是(**A**)

A.患者编号

B.患者姓名

C.患者编号和患者姓名

D.医生编号

---
1. 已知关系Member(S#,Name,D#)和Team(D#,Dname,Leader),其中Member的S#为主
键，D#为外键，且S#范围为1000000-1100000。Team={<’01’,’技术研发’，’赵
六’>，<’02”，’产品运营’，’钱琪？>}。问：下面哪一个选项中的元组可以是
member的元组。(**A**)

A.<‘1000101',null,‘01’>

B.<‘1000102‘,‘张三’，‘05’>

C.<null,'李四'，‘01’>

D.<‘1101010,‘王五’，‘02‘>

---
1. “合同”关系和“客户”关系如下表所示，关于这两个表说法正确的是（**A**）
合同

|      |      |       |        |
| ---- | ---- | ----- | ------ |
| 合同号  | 合同名称 | 合同签订人 | 客户号    |
| HT01 | 钢材合同 | 张三    | CUST01 |
| HT02 | 煤矿合同 | 李四    | CUST02 |
| HT03 | 钢材合同 | 张三    | CUST01 |
客户

|        |      |      |     |
| ------ | ---- | ---- | --- |
| 客户号    | 客户名称 | 客户地址 | 联系人 |
| CUST01 | 首钢   | 北京   | 李吉  |
| CUST02 | 天麟煤矿 | 北京   | 李润  |
| CUST03 | 宝钢   | 上海   | 李癌  |


A.“合同”关系和“客户”关系的主码分别伪“合同号”和“客户号”，“合同”的外
码为“客户号”

B.“合同”关系和“客户”关系的主码都为“客户号”，“合同”的外码为“合同签订
人”

C.“合同”关系和“客户”关系的主码分别伪“合同号”和“客户名称”，“合同”的
外码为“合同签订人”

D.“合同”关系和“客户”关系的主码分别为“合同名称”和“客户号”，“合同”的
外码为“客户

---
1. 关于关系模型完整性的说法，不正确的是(**A**)

A.外键如果取空值，则违反了参照完整性

B.数据库中有了空值会影响许多方面，如影响聚集函数运算的正确性等

C.用户自定义完整性是指用户针对具体的数据库应用所定义的完整性约束条件

D.实体完整性和参照完整性一般由DBMS系统自动支持特

---
1. 关于学生关系，下列哪一个属性适合作为候选码(**A**)

A.学号

B.年龄

C.性别

D.班级

---
1. 关于关系模式与关系，说法不正确的是(**A**)

A.关系模式是稳定的；同一关系模式下，只有一种关系

B.同一关系模式下，可有很多的关系

C.关系模式是关系的结构，关系是关系模式在某一时刻的数据

D.关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的

---
1. 关于关系的特性，说法不正确的是(**A**)

A.关系是以属性在关系的位置来区分的

B.关系是以内容（名字或值）来区分的

C.区分那一列是靠列名

D.区分哪一行是靠某一或某几列的值

----
1. 关于关系的特性，说法不正确的是(**A**)

A.关系的任意两列上的值不能完全相同

B.关系的任意两个元组不能完全相同

C.元组相同是指两个元组的每个分量都相同

D.在同一个关系中如存在相同的元组，则仅保留其中的一个

---
1. 关系模型就是处理Table的，它由哪些部分组成(**A**)

A.关系(或者表)、关系运算和完整性约束

B.关系(或者表)和关系运算

C.关系(或者表）和完整性约束

D.其他选项者都不对

---
1. 关系数据库中，体现“实体能够区分并唯一标识元组”的规则是(**A**)

A.实体完整性规则

B.参照完整性规则

C,用户自定义完整性规

D.属性的值域限定规则

---
1. 根据关系模型的完整性规则，一个关系中的主键（**A**）

A.不允许空值

B.可以有多个

C.不能成为另一个关系的外键

D.可以取空值

---
1. 关系模型中，实体完整性是指(**A**)

A.实体的主码中的属性值不能为空值

B.实体不允许是空实体

C.实体的外键值不允许是空值

D.实体的属性值不能是空值

---
1. 若规定工资表中的基本工资不得超过500元，则这个规则属于(**A**)

A.用户定义完整性约束

B.其他都不是

C.实体完整性约束

D.参照完整性约束

---
1. 关于“关系”的说法，正确的是(**A**)

A.关系是一个由行与列组成的、能够表达数据及数据之间联系的二维表

B.表中某一列的数据可以同时出现字符串与数值

C.表中某一列的值可以取空值null,所谓空值就是空格

D.表中只能有一列作为主关键字，用来唯一标识一行

---
1. 下列几个表符合关系约束的是(**A**)

A.

|     |       |        |     |          |
| --- | ----- | ------ | --- | -------- |
|     |       |        |     |          |
| 1   | Jones | Allan  | 2   | 555-1234 |
| 2   | Smith | John   | 3   | 555-4321 |
| 3   | Brown | Harry  | 2   | 555-1122 |
| 5   | White | Edward | 3   | 555-3344 |

B.

|          |       |      |      |     |        |
| -------- | ----- | ---- | ---- | --- | ------ |
| S#       | Sname | Ssex | Sage | D#  | Sclass |
| 98030101 | 张三    | 男    | 20   | 03  | 980301 |
| 98030102 | 张四    | 女    | 20   | 计算机 | 980301 |
| 98030103 | 张五    | 男    | 19   | 03  | 980301 |
| 98040201 | 王三    | 01   | 20   | 04  | 980402 |
| 98040202 | 王四    | 男    | 21   | 控制  | 980402 |
| 98040203 | 王五    | 02   | 19   | 04  | 980402 |
|          |       |      |      |     |        |
|          |       |      |      |     |        |
C.

| 丈夫  | 妻   | 予女  |     |
| --- | --- | --- | --- |
|     |     | 第一个 | 第二个 |
| 李基  | 王芳  | 李健  |     |
| 张鹏  | 刘区  | 张喜  | 张峰  |

D.

|          |       |      |      |     |        |
| -------- | ----- | ---- | ---- | --- | ------ |
| S#       | Sname | Ssex | Sage | D#  | Sclass |
| 98030101 | 张三    | 男    | 20   | 03  | 980301 |
| 98030102 | 张四    | 女    | 20   | 03  | 980301 |
| 98030103 | 张五    | 男    | 19   | 03  | 980301 |
| 98040201 | 王三    | 男    | 20   | 04  | 980402 |
| 98040202 | 王四    | 男    | 21   | 04  | 980402 |
| 98040203 | 王五    | 女    | 19   | 04  | 980402 |
| 98030103 | 张五    | 男    | 19   | 03  | 980301 |

---

1. 关于关系的特性，说法不正确的是(**A**)

A.表中行的顺序、列的顺序不可以任意交换

B.表中的每一列均需有一个唯一的名字

C.表中不允许出现完全相同的两列

D.表中行的顺序、列的顺序均可以任意交换

---
1. 关系模型中，实现不同关系之间的联系是通过(**A**)

A.外键

B.关系

C.表

D.候选码

---
1. 参照完整性规则是指表的(**A**)必须是另一个表主键的有效值，或者是空值。

A.外键

B.候选键

C.主键

D.主属性

## 4
1. 如下列表所示，两个关系R1和R2,它们进行运算后可以得到R3(**A**)

|      |     |     |     |      |     |     |     |      |     |     |     |     |     |
| ---- | --- | --- | --- | ---- | --- | --- | --- | ---- | --- | --- | --- | --- | --- |
| 关系R1 |     |     |     | 关系R2 |     |     |     | 关系R3 |     |     |     |     |     |
| A    | B   | C   |     | B    | E   | M   |     | A    | B   | C   | E   | M   |     |
| 1    | 1   | X   |     | 1    | m   | 1   |     | 1    | 1   | X   | m   | 1   |     |
| C    | 2   | y   |     | 2    | n   | ]   |     | C    | 2   | y   | n   | J   |     |
| D    | 3   | y   |     | 1    | m   | k   |     | 1    | 1   | X   | m   | K   |     |


A. $R1 \bowtie R2$

B. $R1 \cap R2$

C. $R1 \cup R2$

D. $R1 \times R2$

---

1. 在关系代数运算中，五种基本运算为(**A**)

A.并、差、选择、投影、乘积

B.并、差、选择、投影、自然连接

C.并、差、交、选择、投影

D.并、差、交、选择、乘积

---
1. 自然连接是构成新关系的有效方法。一般情况下，当对关系R和S使用自然连接时，
要求R和S含有一个或多个共有的(**A**)

A.属性

B.元组

C.行

D.域

---

![1741230397849 1](https://github.com/user-attachments/assets/85265abc-55e8-4762-acf1-605274a3fff3)

A

---
1. 系如下图所示，查询既学习课程号为001课程又学习课程号为002号课程的学生的学
号，正确的是(**A**)


![1741230661647](https://github.com/user-attachments/assets/47d8b4a3-26c6-447a-9ec3-a2c458bb2bc0)

![1742783041868](https://github.com/user-attachments/assets/4d733b06-ec46-46c1-ba8c-13d47aac0834)


---
![1742783087729](https://github.com/user-attachments/assets/973803a6-a244-4b95-a60f-a02c525cc165)


(**A**)


![1741230917079](https://github.com/user-attachments/assets/c72b5753-e0ec-47a0-9d49-5b1ee2ba7f20)

A.查询没有学习过课程号为002号课程的学生姓名和年龄

B.查询不仅仅学习课程号为002号课程的学生姓名和年龄

C.查询学习课程号为002号课程的学生姓名和年龄

D.其他全不对

---
1. 关系R与关系S只有一个公共属性，T1是R与S做 $\theta$ 连接的结果，T2是R与S自然连接
的结果，则下列说法正确的是(**A**)

A.T1的属性个数大于T2的属性个数

B.T1的属性个数等于T2

C.T1的属性个数小于T2

D.T1的属性个数大于或等于T2的属性个数

---
1. 已知关系课程表C,用关系代数查询“程军”老师所授课程的课程号(C#)和课程
名(Cname),正确的是(**A**)

|     |       |     |     |     |
| --- | ----- | --- | --- | --- |
|     |       |     |     |     |
| K1  | c语言   | 王华  |     |     |
| K5  | 数据库原理 | 程军  |     |     |
| K8  | 编译原理  | 程军  |     |     |


![1741231491085](https://github.com/user-attachments/assets/e4a493ea-a1a7-4ad5-be87-a5a0130b3fd2)

---
1. 学生表如图所示，用关系代数查询所有在3系就读的且年龄小于21的学生的学号和姓
名。表达正确的是(**A**)

|          |       |      |      |     |        |
| -------- | ----- | ---- | ---- | --- | ------ |
| S#       | Sname | Ssex | Sage | D#  | Sclass |
| 98030101 | 张车    | 男    | 20   | 03  | 980301 |
| 98030102 | 张四    | 女    | 21   | 03  | 980301 |
| 98030103 | 张五    | 男    | 19   | 03  | 980301 |
| 98040201 | 王三    | 男    | 18   | 04  | 980402 |
| 98040202 | 王四    | 男    | 21   | 04  | 980402 |
| 98050104 | 孙六    | 女    | 19   |  05 | 980501 |

![1742783209512](https://github.com/user-attachments/assets/28cdd3f9-f212-4de1-9328-2d939197657f)


---

---
1. 学生表如下图所示，用关系代数查询不在（年龄大于20的3系同学）要求之内的所有其
他同学的信息，正确的是(**A**)

|          |       |      |      |     |        |
| -------- | ----- | ---- | ---- | --- | ------ |
| S#       | Sname | Ssex | Sage | D#  | Sclass |
| 98030101 | 张三    | 男    | 20   | 03  | 980301 |
| 98030102 | 张9    | 女    | 21   | 03  | 980301 |
| 98030103 | 张五    | 男    | 19   | 03  | 980301 |
| 98040201 | 王三    | 男    | 18   | 04  | 980402 |
| 98040202 | 王四    | 男    | 21   | 04  | 980402 |
| 98050104 | 孙六    | 女    | 19   | 05  | 980501 |


![1741231934693](https://github.com/user-attachments/assets/f2067f6f-b593-44f6-983b-460dc7893a77)

---
![1742783346304](https://github.com/user-attachments/assets/73e56066-a413-4f3d-89a2-88dbffff5176)

(**A**)

---
1。已知关系S(S#,Sname,,Sage,Sclass)),SC(S#,C#,Score)。如下所示关系代数表达式的含义是(**A**)

![1742783382373](https://github.com/user-attachments/assets/9c615f2d-ac16-4dc5-b52d-d911907f8f43)

A.其他全不对

B.查询没有学习过课程号为002号课程的学生姓名和年龄

C.查询不仅仅学习课程号为002号课程的学生姓名和年龄

D.查询学习课程号为002号课程的学生姓名和年龄

---
1. 现有关系数据库如下：学生（学号，姓名，性别，专业），课程（课程号，课程
名，学分)，选课（学号，课程号，分数）。检索“‘数据库’课程不及格学生的
学号、姓名和分数”。其正确的关系代数表达式是(**A**)


![1741232308797](https://github.com/user-attachments/assets/098d6a27-9b6e-4755-8ca7-4f2244b8dc37)

---
1. 已知关系：学生（学号，姓名，性别，年龄），课程（课程号，课程名，学分），
选课（课程号，学号，成绩）。表达“查询年龄未满20岁的学生姓名及年龄”的关
系代数表达式是(**A**)


![1741232381691](https://github.com/user-attachments/assets/b523d9df-c2d2-45f5-a79a-fd8783855484)

---
1. 已知关系：学生（学号，姓名，性别，年龄），课程（课程号，课程名，学分），选课（课程号，学号，成绩）。表示“查询没有选修数据库课程的学生姓名”的关系代数操作是(**A**)


![1741232453547](https://github.com/user-attachments/assets/a005c62f-3e92-4fc6-b084-c17e837d9547)


---
1. 已知关系：学生（学号，姓名，性别，年龄），课程（课程号，课程名，教师，学分），选课（学号，课程号，成绩）。表达查询“选修了教师01所教全部课程的学生的姓名”的关系代数操作是(**A**)

![1741232534919](https://github.com/user-attachments/assets/574f1e09-4f56-42bf-9a5e-5648154cc066)

---
1. 表达“从一个关系的所有行中提取出满足某些条件的行”，“从一个关系的所有列
中提取出某些列”“提取出属于一个关系但不属于另一关系的所有元组”“将两个
关系必须按照某种条件串接成一个较大的关系”的操作依次是(**A**)

1、并2、交3、积4、选择5、投影6、差7、连接

A.4567

B.4537

C.3567

D.4561

---
1. 下列说法正确的是(**A**)

A.R×S与S×R运算的结果是同一个关系

B.RUS与SUR运算的结果不是同一个关系

C.R-S与S-R运算的结果是同一个关系

D.其余说法都不对

----
1. 设关系R、S、Z各有10个元组，那么这三个关系的笛卡尔积的元组个数是(**A**)

A.1000

B.10

C.30

D.不确定

---
1. 设关系R和S的元组个数分别为100和300，关系T是R与S的笛卡尔积，则T的元组个数
是(**A**)

A.30000

B.400

C.10000

D.90000

---
1. 设关系R与关系S具有相同的目数（或称度数），且相对应属性的值取自同一个域，
则R-(R-S)等于(**A**)

A.R∩S

B.RUS

C.S-R

D.S

---
1. 假定学生关系是S(S#,Sname,,Ssex,Sage),课程关系是C(C#,Cname,Cteacher),学生选课关系是SC(S#,C#,Score),要查找“选修‘COMPUTER'课程的女学生的姓名”，其正确的关系代数表达式是(**A**)


![1741232877993](https://github.com/user-attachments/assets/fbd68d50-ac8b-4909-b0fd-8ee191743017)

---
1. 设关系R和S的属性个数分别为和m,那么RXS操作结果的属性个数为(**A**)

A.n+m

B.n-m

C.nxm

D.max(n,m)

---
1. 设1,2是条件表达式，of1(o f2(R))等价于(**A**)


![1741233255320](https://github.com/user-attachments/assets/f3ab98a7-3611-4730-a0e0-a4ac0cc69221)

## 5
1. 关于关系运算，下列说法正确的是(**A**)

A.安全的元组演算公式和安全的域演算公式可以等价变换

B.关系代数运算和关系演算之间是互补的，即它们可以利用各自特点解决彼此不能解决
的问题

C.关系代数和关系演算不一定是安全的

D.关系演算以属性为基本处理单位

---
1. 集合R与S的"差"表示为(**A**)


![1742371791473](https://github.com/user-attachments/assets/7d2c71a5-8a14-4abf-a543-e36e48c5a42a)


---

1. 集合R与S的笛卡尔积表示为(**A**)

![1742371808495](https://github.com/user-attachments/assets/4a5d921d-3819-4fb4-9c65-b56d9408b45d)


---
1. 集合R与S的"并"表示为(**A**)

![1742371826583](https://github.com/user-attachments/assets/e40cb275-8b27-4b10-985c-d0aa9d7a0cbe)


---
1.已知下述关系，S(学号，姓名，年龄，性别，院系)，SC(学号，课程号，分数)，C(课程号，课程名，学分，教师名)。检索学习过刘玲老师所授课程的所有学生。表达正确的是(**A**)

![1742371850742](https://github.com/user-attachments/assets/ffe0c93b-1462-41ba-9391-9e150b3f3ef0)


---
1. 已知下述关系，S(学号，姓名，年龄，性别，院系)，SC(学号，课程号，分数)，C(课程号，课程名，学分，教师名)。检索学号为S3学生所学课程的课程号与任课教师名。表达正确的是(**A**)

![1742371874430](https://github.com/user-attachments/assets/78911fb3-8f14-4f9d-9f0e-279a9d58e700)

---
1. 已知关系Student(S#,Sname,Sage,D#),Dept(D#,Dname,Dean),利用元组演算查询“计算机系所有学生的信息”：对以下元组演算公式，请补充下划线里的内容：(**A**)
 
$$\{t\mid t\in Student\wedge\_(u\in DEPT)(u[\_]=t[4]\wedge u[\_]=t[4]\times u[\_]=\text{计算机 })\}$$

A. $\exists$ ,1,2

B. $\exists$ ,2,1

C. $\forall$ ,2,1

D. $\forall$ ,1,2

---
1. R(S#,Sname,Sage,Sclass),Z(S#,Sname,Sage,Sclass)表达“t属于R或t属于Z,并且t的年龄大于20”的关系元组演算公式为(**A**)

![1741242955026](https://github.com/user-attachments/assets/202b06cb-0509-4ead-b7de-a260e95d4b56)

----
1. 己知下述关系，Student(学号，姓名，年龄，性别，院系)，SC(学号，课程号，分数)，C(课程号，课程名，学分，教师名)。请用关系演算公式表达“检索出年龄不是最小的，所学课程都及格的所有同学”，表达结果正确的是(**A**)

![1741243306693](https://github.com/user-attachments/assets/fecd4f58-cb2f-4c50-adda-abb3ddc99797)

---
1. 关于关系运算的安全性，说法不正确的是(**A**)

A.关系演算是安全的

B.关系代数是一种集合运算，是安全的

C.任何公式都在一个集合范围内操作，而不是无限范围内操作，才能保证其安全性。

D.集合本身是有限的，有限元素集合的有限次运算仍旧是有限的

---
1. 关于关系运算的说法，不正确的是(**A**)

A.相比之下：域演算的非过程性最好，关系代数次之，元组演算最差

B.关系代数与安全的元组演算表达式与安全的域演算表达式是等价的

C.一个数据库语言如果能够等价地实现这三种关系运算的操作，则说该语言是完备的

D.目前多数数据库语言都能够实现这三种运算的操作，在此基础上还增加了许多其他
的操作，如赋值操作、聚集操作等

---
1. 请写出下面语句的逻辑含义。正确的是(**A**)

![1741243713179](https://github.com/user-attachments/assets/e95caa22-2833-4fab-9897-4154e7609e2c)

A.或者年龄不小于20岁，或者既为03系又为男生的学生

B.或者年龄小于20岁，或者03系的男学生

C.年龄大于等于20岁且不是03系的男学生

D.或者年龄不小于20岁，或者03系。且为男生的学生

---
![1741243919716](https://github.com/user-attachments/assets/aa0e7e81-a1f8-4700-ae19-acc4c853d615)

![1741243955031](https://github.com/user-attachments/assets/6f51e381-ba42-4f23-a2ff-e165a6b36f0a)

(**A**)

---
1. 基于关系域演算的QBE语言，QBE操作框架由(**A**)构成。

A.关系名、属性名、操作命令、查询条件

B.关系名、属性名、查询条件

C.关系名、属性名、操作命令

D.属性名、查询条件、操作命令

---
1. 以下元组演算公式与关系代数RUS、R-S、R $\cap$ S的等价性相对应的一组是(**A**)

![1741244126634](https://github.com/user-attachments/assets/563ae088-8703-4c22-b0d0-5b8b0e80659d)

## 6
1. SQL语言集数据查询、数据操纵、数据定义和数据控制功能于一体，其中，CREATE、
DROP、ALTER语句是实现哪种功能(**A**)

A.数据定义

B.数据查询

C.数据操纵

D.数据控制

---
1. 己知有：学生表Student(S# char(⑧)，Sname char(IO),Ssex char(2),Sage integer,D# char(2),Sclass char(⑥)中，若要在学生表中追加一个元组“学号为98030101的男同学张三，年龄为20，所属系别03，所在班级980301”，则可用(**A**)

A.INSERT INTO Student VALUES(‘98030101',‘张三’，‘男'，20,‘03’,‘980301’)

B.ADD INTO Student VALUES(‘98030101’,‘张三’，‘男’，20，‘03'，‘980301’)

C.INSERT INTO Student VALUES(9803010,张三，男，20,03,980301)：

D.ADD INTO Student VALUES(98030101.张三，男，20,03,980301)：

---
1. 有学生表Student(S#char(⑧)，Sname char(I0),Ssex char(2),Sage integer,D# char(2),Sclass char(6)。要检索学生表中“所有年龄小于等于19岁的学生的年龄及姓名”，SQL语句正确的是(**A**)

A.Select Sage,Sname From Student Where Sage <=19;

B.Select Sname From Student Where Sage <=19;

C.Select From Student Where Sage <19;

D.Select Sage,Sname From Student;

---
1. 若用如下的SQL语句创建一个表SC:CREATE TABLE SC(S# CHAR(6)NOT NULL,C# CHAR(3)NOT NULL,SCORE INTEGER,NOTE CHAR(20)):向SC表中插入如下行时，()行可以被插入。(**A**)

A.(‘200823',‘101’,NULL,NULL)

B.(‘201009',‘101’,NULL,必修)

C.(NULL,‘103’,80,‘选修’)

D.(‘201132’,NULL,86,’)

---
1. 有学生表Student(S#char(⑧)，Sname char(I0),Ssex char(2),Sage integer,.D# char(2),Sclass char(6)。若要“检索名字为张某某的所有同学姓名”，SQL语句正确的是(**A**)

A.Select Sname From Student Where Sname Like‘张_'：

B.Select Sname From Student Where Sname Like '张%'

c.Select Sname From Student Where Sname Like‘张_  \_'；

D.Select Sname From Student Where Sname Not Like‘张_  \_'；

---
1. 在关系模型中关于结果唯一性问题，结果排序问题，模糊查询问题，如下说法不正确的是(**A**)

A.结果排序是在Select语句中通过增加order by子句实现的，后只能跟DESC或省略为降
序。

B.在Table中要求无重复元组是通过定义Primary keyi或Unique来保证的；而在检索结果中
要求无重复元组，是通过在SELECT子句中引入DISTINCT保留字来实现的。

C.模糊查询是通过在Select语句的Where子句中引入运算符lke来实现的

D.在SELECT语句的Lk条件中，用“%”去匹配字符%，用趴去匹配字符

---
1. 有关系表SC(S#,C#,Score),求既学过“001”号课又学过“002”号课的所有学生的学
号，下列SQL语句正确的是(**A**)

![1741314572951](https://github.com/user-attachments/assets/8f149f8c-797a-4d8c-8339-daca716f8976)

---
1. 有关系表SC(S#,C#,Score)，求“001”号课成绩比“002”号课成绩高的所有学生的学
号。下列SQL语句正确的是(**A**)

![1741314715906 1](https://github.com/user-attachments/assets/b5abf422-667d-4096-ae11-ec2e5c016a1f)

---
1. 假设学生关系S(S#,SNAME,SEX),课程关系C(C#,CNAME),学生选课关系SC
(S#,C#,GRADE)。要查询选修“Computer”课的男生姓名，将涉及到关系(**A**)

A.S,C,SC

B.S

C.S,SC

D.SC

---
1. SQL语言中，删除一个表的命令是(**A**)

A.DROP

B.DELETE

C.CLEAR

D.REMOVE

---
1. 学生关系S(S#,Sname,.Ssex,Sage,D#,Sclass),S的属性分别表示学生的学号、姓名、性别、年龄。要在表S中删除一个属性“年龄”，可选用的SQL语句是(**A**)

A.ALTER TABLE S DROP Sage

B.DELETE Sage from

C.UPDATE S Sage

D.ALTER TABLE S'Sage'

---
1. 若要撤销数据库中己经存在的表S,可用(**A**)

A.DROP TABLE S

B.DELETE TABLE S

C.DELETE S

D.DROP S

---
1. WHERE条件中出现LIKE'\_A%',下面哪一个结果是可以被检索出来的(**A**)

A.BAI

B.AILI

C.CCA

D.以上所有都可以被检索出来

---
1. 查询时，若要输出无重复的记录，SELECT子句中使用的保留字是：(**A**)

A.DISTINCT

B.ALL

C.TOPN

D.TOPNPERCENT

---
1. 查询结果输出时要求按“总评成绩”降序排列，相同者按“性别”升序，正确的子句是(**A**)

A.ORDER BY总评成绩DESC,性别

B.ORDER BY总评成绩.性别DESC

C.ORDER BY总评成绩DESC,性别DESC

D.ORDER BY总评成绩ASC,性别DESC

---
1. 在下列SQL语句中，属于数据控制语言DCL的是1、CREATE2、SELECT3、UPDATE4、GRANT5、DELETE6、ALTER7、INSERT8、REVOKE(**A**)

A.4,8

B.1,5,6,7

C.2,3,6,8

D.1,5,7

---
1. 已知关系S(S#,SN,AGE,SEX),SC(C#,S#,GRADE),C(C#,CN,TEACHER)。若要检索学生姓名及其选修课程的课程号和成绩，正确的SELECT语句是(**A**)

A.SELECT S.SN.SC.C#.SC.GRADE FROM S,SC WHERE S.S#=SC.S#

B.SELECT S.SN.SC.C#.SC.GRADE FROM S WHERE S.S#=SC.S#

C.SELECT S.SN.SC.C#.SC.GRADE FROM SC WHERE S.S#=SC.GRADE

D.SELECT S.SN.SC.C#,SC.GRADE FROM S.SC

---
1. INSERT INTO Goods(Name,Storage,Price)VALUES ('Keyboard',3000,90.00)
作用是(**A**)

A.添加数据到一行中的部分列

B.添加数据到一行中的所有列

C.插入默认值

D.插入多个行

---
1. 己知如下关系：学生Student(S#,Sname),课程Course(C#,Cname,T#),选课SC(S#,
C#,Score),教师T(T#,Tname)。其中S#为学号，Sname为学生命名，C#为课号，
Cname为课程名，T#为教师编号，Score.为成绩，Tname为教师名。
阅读SQL语句：
SELECT Sname FROM Student,SC,Course WHERE Student.S#=SC.S#AND
Course.C#=SC.C#AND T#=T01'AND Score<60:
关于其查询结果，下列说法正确的是(**A**)

A,学习T01号教师讲授课程不及格的所有学生的姓名

B.学习T01号教师讲授课程及格的所有学生的姓名

C.学习非T01号教师讲授课程不及格的所有学生的姓名

D.课程不及格的所有学生的姓名

---
1. 如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。

![1741315396950](https://github.com/user-attachments/assets/530f571f-08c3-4229-b790-5597e62083bf)

将“选课”表中的1002号课的所有成绩提高10分，正确的SQL语句是(**A**)

A.UPDATE 选课 SET 成绩=成绩+10 WHERE课号=‘1002'：

B.UPDATE 选课 SET 成绩=成绩+10 WHERE课号=1002：

C.SET 选课 UPDATE 成绩=成绩+10 WHERE课号=‘1002'：

D.UPDATE 选课 SET 成绩+10 WHERE课号=‘1002'；

---
1. 如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。

![1741315736887](https://github.com/user-attachments/assets/a04adbf7-c401-496e-90ed-05ccd167580f)

从“课程”表中将2003号课去掉，正确的SQL语句是(**A**)

A.DELETE FROM 课程 WHERE课号=‘2OO3':

B.DELETE FROM 课程 WHERE课号=2003：

C.DELETE FROM课程 WHERE‘2003':

D.DELETE FROM课程.课号=‘2003’：

---
1. 如下几个表所示学生、课程、必修课和选课关系。

![1741315879421](https://github.com/user-attachments/assets/3ba251d1-d21d-46ae-b583-2e9226be726d)

己知SQL语句“SELECT DISTINCT课号FROM必修课：”，其正确的检索结果是(**A**)

![1741315926051](https://github.com/user-attachments/assets/459b7c0d-25d6-470e-a762-c38c262cbcae)


---
1. 如下几个表所示学生、课程、必修课和选课关系

![1741316002361](https://github.com/user-attachments/assets/6eeefeee-c4fb-4035-b4ba-2e611a56a246)

己知SQL语句是“SELECT DISTINCT 学号 FROM 选课 WHERE课号=‘1002'”OR
课号=‘2002'：正确的结果是(**A**)。

![1741316034968](https://github.com/user-attachments/assets/7e9a259b-358b-4341-9d19-2f6737aaed03)

---
1. 在SELECT语句中，与关系代数中σ运算符对应的是子句(**A**)

A.WHERE

B.SELECT

C.FROM

D.GROUP BY

---
1, 在SELECT语句中，与关系代数中π运算符对应的是子句(**A**)。

A.SELECT

B.FROM

C.WHERE

D.GROUP BY

---
1. 己知SC(S#,C#,Score)关系的元组，如下所示{<S1,C1,80>,<S1,C2,90>,<S1,C3,60>,<S2,C1,75>,<S2,C2,80>,<S3,C2,85>,<S3,C3,75>,<S4,C2,80>,<55,C3,50>,<S5,C1,85>}。关于“SELECT S# FROM SC WHERE C# = ‘C1'and C# =' C3'”,下列说法正确的是(**A**)

A。共它说法都不正确

B.该查询结果中的元组为{S1,S5}:

C.该查询结果中的元组为{S1,S2,S3,S5}:

D.该查询结果中的元组为{S1};
## 7
1. 己S(S#,SN,AGE,SEX),S#学号，SN姓名。若要检索所有比王华年龄大的学生姓名、年龄和性别，正确的SELECT语句是(**A**)

A.SELECT SN,AGE,SEX FROM S WHERE AGE>(SELECT AGE FROM S WHERE SN=王华)

B.SELECT SN,AGE,SEX FROM S WHERE SN-'王华'

C.SELECT SN.AGE,SEX FROM S WHERE AGE>(SELECT AGE WHERE SN-'E)

D.SELECT SN.AGE,SEX FROM S WHERE AGE>王华.AGE

---
1. 在SQL语言中，子查询是(**A**)

A.嵌入到另一个查询语句之中的查询语句

B.返回单表中数据子集的查询语言

C,返回单表中数据子集的查询语言

D,选取单表中字段子集的查询语句

---
1. 设关系Teacher的结构为：Teacher(T#char(3),Tname char(IO),D#cha(2),Salary
float(2),其中T#教师编号，Tname教师姓名，D#系号，Salary工资。Dept(D#
char(2),Dname char(1O),Dean char(10),Dname系名，Dean系主任。若要将所有计算机系的教师工资上调10%，则可用(**A**)

A.Update Teacher Set Salary=Salary\*1.1 Where D# in (Select D# From Dept Where
Dname=‘计算机’)：

B.Update Salary=Salary\*1.1 Where D# in (Select D# From Dept Where Dname=‘计算
机’)：

C.Update Salary=Salary\*l.1 Where D# in(Select D# From Dept Where Dname='计算机')：

D.Update TABLE Teacher Set Salary=Salary\*1.1 Where D# in (Select D# From Dept
Where Dname=‘计算机')：

---
1. 己知Titles(Title_ld char(4),Title char(20),Pub_id char(4),price integer),其中
Title_Id图书编号，Title图书名，Pub_id出版商编号，price价格。列出Titles表中其价
格高于出版商D为0736的出版商出版的书的最大价格的书的标题和ID,合适的查询语句
是(**A**)

A.SELECT Title_Id,Title FROM Titles WHERE price>ALL (SELECT price FROM Titles
WHERE Pub_id=‘0736')

B.SELECT Title_Id,Title FROM Titles WHERE price>ALL (SELECT price FROM
Titles) AND Pub_id='0736

C.SELECT Title_Id,Title FROM Titles WHERE price>ANY (SELECT price FROM Titles
VHERE Pub_id=‘0736')

D.SELECT Title_Id,Title FROM Titles WHERE price>ANY (SELECT price FROM
Titles)AND Pub_id='0736'

---
1. 陈述A:SubQuery1 UNION SubQuery2语句，其中SubQuery1和SubQuery2查询中相应的列必须以同一顺序出现。陈述B:GROUP BY和HAVG子句不能在子查询中使用，这些子句只能用在最后一个查询结束时来总结和排序最后结果集。关于陈述A和B,下列说法正确的是(**A**)

A.陈述A正确，陈述B错误

B.都是正确的

C,都是错误的

D.陈述A错误，陈述B正确

---
1. 下面有关HAVING了句，说法不正确的是(**A**)

A.使用HAVING子句的同时不能使用WHERE子句

B.HAVING子句必须与GROUP BY子句同时使用，不能单独使用

C.使用HAVING子句的同时可以使WHERE子句

D.使用HAVING子句的作用是过滤掉不满足条件的分组

---
1. 在SQL中，与"NOT IN"等价的操作符是(**A**)

A.<>ALL

B.SOME

C.<>SOME

D.=ALL

---
1. 以下定义的4个视图中，能够进行更新操作的是(**A**)

![1741317869203](https://github.com/user-attachments/assets/674b4734-c5d0-47dd-8c90-9ccb69173b97)

---
1. 己知选课关系SC(S# char(8),C# char(8),GRADE integer),S#学号，C#课程号，GRADE成绩。检索选修4门以上课程的学生总成绩（不统计不及格的课程），并要求按总成绩的降序排列出来。正确的SELECT语句是(**A**)

![1741318152712](https://github.com/user-attachments/assets/0ba4690e-f1a6-4e6a-9bdb-1291aa204b2f)

---
1. 关于SQL视图更新的可执行性，下列说法不正确的是(**A**)

A.对于由单一Table子集构成的视图，即如果视图是从单个基本表使用选择、投影操作
导出的，并且包含了基本表的主键，则不能更新

B.如果视图的select目标列包含聚集函数，则不能更新

C.如果视图中包括了group by子句，则不能更新

D.如果视图是由单个表的列构成，但并没有包括主键，则不能更新

---
1. 已知关系模式Student(S# char(8),Primary key,Sname char(10),Ssex char(2),Sage
integer,D# char(2),Sclass char(6)，在此基础上定义了视图create view CStud(S#,
Sname,Sclass)as(select S#,Sname,Sclass from Student where D#=‘03')。若要对该视
图进行更新，下列语句正确的是(**A**)

A.Insert into CStud Values(“98030104”,“张三丰”，“980301”);

B.Insert into CStud Values(98030104,“张三丰”，“980301”);

C.insert into CStud values(“98030104”,张三丰，NulL,Null,“03”,“980301”):

D.insert into CStud values (Null,“张三丰”，“980301”);

---
1.合并多个查询结果集，应使用(**A**)保留字。

A.union

B.join

C.into

D.and

---
1. 假如有两个表的连接是这样的：table1 INNER JOIN table2,其中table1和table2是两
个具有公共属性的表，这种连接会生成哪种结果集(**A**)

A.只包括table1和table2中满足条件的行的组合结果

B.包括table1中的所有行但不包括table2的不匹配行的所有组合结果

C.包括table2中的所有行但不包括table1的不匹配行的所有组合结果

D.包括两个表的所有行的组合结果

---
1. 有关SQL语言的空值处理，以下说法不正确的是(**A**)

A.除is [not] null之外，空值满足任何查找条件

B.如果null参与比较运算，有些情况下是可以判断为真的或为假的。

C.如果null参与聚集运算，则除count(\*))之外其它聚集函数都忽略null

D.如果null参与算术运算，则该算术表达式的值为null

---
1. 求既学过002号课，又学过003号课的同学学号，下列SQL语句不正确的是(**A**)

A.Select S#From SC Where C#=002'AND C#='003':

B.Select S#From SC Where C#='002' INTERSECT Select S# From SC Where C#='003';

C.Select S#From SC Where C#='002'and S# IN (Select S#From SC Where C#='003');

D.Select S1.S#From SC S1,SC S2 Where S1.S#S2.S#and S1.C#='002'and S2.C#='003

---
1. 己知如下关系：学生Student(S#,Sname),课程Course(C#,Cname,T#),选课SC(S#,
C#,Score),教师T(T#,Tname)。其中S#为学号，Sname为学生命名，C#为课号，
Cname为课程名，T#为教师编号，Score为成绩，Tname为教师名。
阅读SQL语句：

SELECT Sname FROM Student WHERE S# NOT IN
(SELECT S# FROM SC WHERE Student.S#=SC.S# and C#='C01'and
Score>=60):

关于其查询结果，下列说法正确的是(**A**)

A.剔出掉C01号课程及格学生的其他学生的姓名

B.C01号课程及格的所有学生的姓名

C.C01号课程不及格的所有学生的姓名

D.剔出掉C01号课程不及格学生的其他学生的姓名

---
1. 已知如下关系：学生Student(S#，Sname)，课程Course(C#，Cname，T#)，选课SC(S#，C#，Score)，教师T（T#，Tname)。其中S#为学号，Sname为学生命名，C#为课号，Cname为课程名，T#为教师编号，Score为成绩，Tname为教师名。
阅读SQL语句

SELECT Sname  FROM Student WHERE S# IN
(SELEC TS# FROM SC WHERE Student.S#=SC.S#and C#=‘C01’and
Score>=60);

关于其查询结果，下列说法正确的是(**A**)

A.C01号课程及格的所有学生的姓名

B.C01号课程不及格的所有学生的姓名

C.剔出掉C01号课程不及格学生的其他学生的姓名

D.剔出掉C01号课程及格学生的其他学生的姓名

---
1. 已知如下关系：学生Student(S#,Sname),课程Course(C#,Cname,T),选课SC(S#,
C#,Score),教师T(T#,Tname)。其中S#为学号，Sname为学生命名，c#为课号，
Cname为课程名，T#为教师编号，Score为成绩，Tname为教师名。
阅读SQL语句

SELECT Sname FROM Student WHERE S# NOT IN(
SELECT S# FROM SC,Course WHERE T#=03'and SC.C#=C.C#);

关于其查询结果，下列说法正确的是一。(**A**)

A.没学过03号教师讲授过的任一门课的学生的姓名

B.学过03号教师讲授过的某一门课的学生的姓名

C.学过03号教师讲授过的所有门课的学生的姓名

D.没学全03号教师讲授过的所有门课的学生的姓名

---
1. 已知如下关系：学生Student(S#,Sname),课程Course(C#,Cname,T#),选课SC(S#,
C#,Score),教师T(T#,Tname)。其中s#为学号，Sname为学生命名，C#为课号，
Cname为课程名，T#为教师编号，Score为成绩，Tname为教师名。
阅读SQL语句

SELECT S# FROM SC WHERE Score<60 AND Count(\*)>2 GROUP BY S#;

关于其查询结果，下列说法正确的是(**A**)

A.其它选项的说法都不正确

B.有2门以上不及格课程的同学的学号

C.有2门以上及格课程的同学的学号

D.有2人以上不及格课程的同学的学号

---
1. 己知如下关系：学生Student(S#,Sname),i课程Course(C#,Cname,T#),选课SC(s#,
C#,Score),教师T(T#,Tname)。共中S#为学号，Sname为学生命名，C#为课号，
Cname为课程名，T#为教师编号，Score.为成绩，Tname为教师名。
阅读SQL语句

Select Sname From Student Where S# NOT IN (Select S# From SC,Course C,
Teacher T Where T.T#=‘李明'and SC.C#=C.C#andT,T#=C.T#)i

关于共查询结果，下列说法正确的是(**A**)

A.列出没学过李明老师讲授任一课程的学生姓名

B.列出学全了李明老师讲授所有课程的学生姓名

C.列出学过李明老师讲授某一课程的学生姓名

D.列出没学全李明老师讲授所有课程的学生姓名

---
1. 已知如下关系：学生Student(S#,Sname),课程Course(c#,Cname,T),选课SC(S#,
C#,Score),教师T(T#,Tname)。其中S#为学号，Sname.为学生命名，C#为课号，
Cname为课程名，T#为教师编号，Score.为成绩，Tname.为教师名。
阅读SQL语句

Select S# From SC SC1 Where SC1.C#='C01'AND S# IN
(Select S# From SC SC2 Where SC2.C#=C02'AND SC1.S#=SC2.S# AND
SC1.Score>SC2.Score):

关于其查询结果，下列说法正确的是(**A**)

A.C01课程比C02课程成绩高的所有学生的学号

B.C01同学比C02同学成绩高的所有课程的课号

C.比C02课程成绩高的所有学生的学号

D.其它选项的说法都不正确

---
1. 现有关系数据库如下：学生（学号，姓名，性别，专业、奖学金），课程（课程号，课程名，学分)，选课（学号，课程号，分数），用SQL语言实现题目：检索没有任何一门课程成绩在80分以下的所有学生的信息，包括学号、姓名和专业，正确的SQL语句是(**A**)

A.SELECT学号，姓名，专业FROM学生WHERE学号NOT IN (SELECT学号FROM
选课WHERE分数<8O)

B.SELECT学号，姓名，专业FROM学生，选课WHERE学号NOT IN(SELECT学
号FROM选课WHERE分数<80】

C.SELECT学号，姓名，专业FROM学生，选课HERE学号 IN(SELECT学号
FROM选课WHERE分数<8O)

D.SELECT学号，姓名，专业FROM学生WHERE学号IN(SELECT学号FROM选
课WHERE学生.学号-选课.学号AND分数<80)

---
1. 现有关系数据库如下：学生（学号，姓名，性别，专业、奖学金），课程（课程号，课程名，学分)，选课（学号，课程号，分数），用SQL语言实现题目：对成绩得过满分(100分)的学生，如果没有获得奖学金的，将其奖学金设为1000元，正确的SQL语句是(**A**)

A.UPDATE 学生 SET奖学金=1000 WHERE奖学金<=0AND学号IN(SELECT学号
FROM选课WHERE分数=100)

B.UPDATE 学生 SET奖学金=1000 WHERE奖学金≤0AND学号I(SELECT学号
FROM 选课 WHERE分数=100)

C.UPDATE 学生 SET奖学金='1000'WHERE奖学金<=0AND学号IN(SELECT学
号FROM 选课 WHERE分数=100)

D.UPDATE 学生 SET奖学金=1000 WHERE奖学金<=0AND学号NOT IN(SELECT学
号FROM 选课 WHERE分数=100)

---
![1741320379223](https://github.com/user-attachments/assets/148d9626-19a1-4d54-9426-6ab30c93065a)

求既学过“1001”号课，又学过“2002”号课的所有学生的学号。正确的SQL语句是(**A**)

![1741320430131](https://github.com/user-attachments/assets/a29be624-4694-40f7-8a46-fadebbbedd3e)

---
![1741320485419](https://github.com/user-attachments/assets/8d86c019-2f73-4ea4-9ad4-ecba7c0ffae1)

(**A**)

---
![1741320573118](https://github.com/user-attachments/assets/3431d820-e4ba-4dec-996d-70dc6fd77bf5)

(**A**)

---
![1741320643428](https://github.com/user-attachments/assets/6391aa45-e20a-481f-b180-c2413e009759)

(**A**)

---
![1741320705870](https://github.com/user-attachments/assets/07d50053-799e-4566-af08-d01a76812126)

(**A**)

---
1. 假设一个元组在子查询1中出现m次，在子查询2中出现n次，其中m>0,n>0,划下列说法正确的是(**A**)

A.该元组在“子查询1 Except 子查询2”中出现0次：

B.该元组在“子查询1 Union 子查询2”中出现m+n次

C.该元组在“子查询1 Except ALL 子查询2”中出现m-n次

D.该元组在“了查询1 Intersect 子查询2”中出现min(m.n)次：

---
1. 假设一个元组在子查询1中出现m次，在子查询2中出现n次，其中m>0,>0,则下列说法正确的是(**A**)

A,该元组在“子查询1 Union ALL子查询2”中出现m+n次；

B.该元组在“子查询1 Union 子查询2”中出现m+n次：

C.该元组在“子查询1 Union ALL子查询2”中出现1次：

D.该元组在“子查询1 Union 子查询2”中出现Min(m,n)次：

---
1. 假设一个元组在子查询1中出现m次，在子查询2中出现n次，其中m>0,>0,则下列说法正确的是(**A**)

A.该元组在“子查询1 Except 子查询2”中出现0次：

B.该元组在“子查询1 Union 子查询2”中出现m+n次：

C.该元组在“子查询1 Except All 子查询2”中出现m-n次：

D.该元组在“子查询1 Union All 子查询2”中出现max(m,n)次：

---
1. 在下列关于视图的叙述中，正确的是(**A**)

A.当某一视图删除后，由该视图导出的其它视图也将自动删除：

B.若导出某视图的基本表被删除，该视图将不受任何影响：

C.视图一旦建立，就不能被删除：

D.当修改某一视图时，导出该视图的基本表也随之修改。

---
1. SQL语言中的视图是一种(**A**)

A.子模式及子模式到模式的映像：

B.全局模式及全局模式到子模式的映像：

C.内模式及内模式到模式的映像：

D.模式及模式到概念模式的映像：

---
![1741321348175](https://github.com/user-attachments/assets/de9b3b2a-e914-48c2-94fe-5154f27c5c8a)

(**A**)
---
![1741321403031](https://github.com/user-attachments/assets/b0fbb644-3fa0-48af-87c8-c0ca71129b9b)

(**A**)
---
![1741321438083](https://github.com/user-attachments/assets/acedec04-996c-4894-ac6d-28b7a1d7605e)

(**A**)
---
![1741321535156](https://github.com/user-attachments/assets/d143f003-a4ef-4c78-9577-481c7356eaeb)

(**A**)

---
1. 有一个学生表student,包含主键S#(学生编号)等。又有分数表SC,包含S#(学生编
号)、score(分数)等。己知student表中共有50个学生，有45人参加了考试（分数存在
SC表中)，其中10人不及格。执行以下SQL语句：select\* from student where exists
(select S# from SC where score<60),可返回(**A**)条记录。

A.50

B.45

C.10

D.35
## 8
1. SQL语言的GRANT和REVOKE语句主要是用来维护数据库的(**A**)

A.安全性

B.完整性

C.可靠性

D.一致性

---
1. 安全性控制的防范对象是(**A**),防止他们对数据库数据的存取。

A.非法非授权用户

B.不符合语义的数据

C.不正确的数据

D.不符合约束的数据

---
1. 在数据库的安全性控制中，授权的数据对象的(**A**)授权子系统就越灵活。

A.范围越小

B.约束越细致

C.范围越大

D.约束范围大

---
1. 关系模型的完整性包括(**A**)

A.其他都是

B.实体完整性

C.参照完整性

D.用户定义完整性

---
1. 已知employee:表中具有默认约束df_email,删除该约束的语句为(**A**)

A.alter table employee drop constraint df_email

B.alter table employee remove constraint df_email

C.alter table employee delete constraint df_email

D.remove constraint df email from table employee

---
1. 关系模型中有三类基木的完整性约束，定义外部关键字实现的是(**A**)

A.参照完整性

B.实体完整性

C.域完整性

D.实体完整性、参照完整性和域完整性

---
1. Create Table有三种功能，以下不是其中一项功能的是(**A**)

A.定义安全性约束

B.定义关系模式

C.定义完整性约束

D.定义物理存储特性

---
1. Col_const列约束只能应用在单一列上，下面不是应用在单一列上的约束是(**A**)

A.FOREIGN KEY

B.UNIQUE

C.search cond

D.PRIMARY KEY

---
1. 要建立一个约束，保证用户表(use')中年龄(age)必须在16岁以上，下面语句正确的是(**A**)

A.alter table user add constraint ck_age CHECK(age>16)

B.alter table user add constraint df_age DEFAULT(16)for age

C.alter table user add constraint uq_age UNIQUE(age>16)

D.alter table user add constraint df_age DEFAULT(16)
## 9
1. 以下嵌入式SQL语句，没有错误的是(**A**)

A.exec sql select Sname,Sage into: vSname,vSage from Student
where Sname=specName;

B.exec sql begin declare section
char vSname[10],specName[2]="Izt";

int vSage;

C.exec sql select Sname,Sage into :vSname,:vSage from Student
where Sname =:specName;

D.其他有多于一个的选项没有错误。

---
1. 关于事务，下列说法正确的是(**D**)

A.必须以Begin Transaction和End Transaction显性地标记开始和结束；

B.事务在处理过程中是可以被中断的，且中断前的执行结果也是有效的：

C.一个事务仅能包含一条SQL语句，多条SQL语句将产生多个事务：

D.SQL语句在执行过程中，必须有提交或撒消语句才能确认其对数据库的永久操作结
果：

---
1. 关于游标，下列说法正确的是(**A**)

A.游标使用之前需要先声明再打开：

B.一个游标只能打开与关闭一次：

C.游标中的SQL语句被执行并产生结果是在Declare Cursor时进行的：

D.若要重新执行游标中的SQL语句，需要重新声明游标并打开游标：

---
1. 关于游标，下列说法不正确的是(**A**)

A.游标一次定义后只能打开关闭一次，再次使用必须再次定义：

B.游标是指向某检索记录集的指针：

C.游标通过EOF标记记录集的结束：

D.游标定义以后并未立即执行，打开后才执行：

---
1. 嵌入式SQL语言中Whenever的作用范围是(**C**)

A.其后的所有Exec SQL语句直到程序结束：

B.其后的所有Exec SQL语句直到与数据库断开连接：

C.其后的所有Exec SQL语句直到程序中出现另一条相同条件的Whenever语句为止

D.其后的所有Exec SQL语句直到其执行过程中遇到另一条相同条件的Wheneveri语句为
止。

---
1. 关于事务，下列说法不正确的是(**D**)

A.事务是一条或多条SQL语句的一次执行：

B.事务的一组更新操作是原子不可分的：

C.事务的操作状态是正确的，符合一致性的操作规则：

D.并发执行的多个事务之间可能互相影响，需要程序员考虑周全：

---
1. 以下哪一个不是状态捕获语句exec sql whenever condition action中condition.所指代的条件(**D**)

A.SQLERROR

B.NOT FOUND

C.SQLWARNING

D.CONTINUE
---
![1741328405507](https://github.com/user-attachments/assets/bea22a0b-44ae-49d4-99a6-443b17cccb0a)

(**A**)

---
1. 高级语言有变量vSname,vSage,vSpecname。若要从数据库中取出对应值赋给高级语言中的变量，下列表达正确的是(**B**)

A.exec sql select Sname Sage into vSname,vSage from student where Sname=VSpecname

B.exec sql select Sname ,Sage into :vSname,:vSage from student where Sname=:vSpecname

C.select Sname ,Sage into :vSname,:vSage from student where Sname=:vSpecname

D.exec sql vSname,:vSage from student where Sname=:vSpecname
---
![1741328661428](https://github.com/user-attachments/assets/74de410c-b372-4d95-aae3-04d0829641d0)

(**B**)

---
1. 关于嵌入式SQL语言状态捕获处理机制的说法，不正确的是(**B**)

A.状态捕获及处理机制由三部分构成：(1)设置SQL通信区SQLCA:(2)设置状态捕获语
句：(3)状态处理程序。

B.状态捕获语句可以作用于整个程序。

C.状态捕获语句容易引发整个程序进入无限循环：

D.DBMS记录状态信息有三种方法：(1)sqlcode:(2)sqlca.sqlcode:(3)sqlstate

---
1. 在嵌入式SQL语言中使用游标的目的在于(**D**)

A.区分SQL与宿主语言

B.与数据库通信

C.处理错误信息

D.处理多行记录

---
1. 关于游标的使用，如下语句正确的编译顺序是(**B**)
1)exec sql open cur_student;
2)exec sql fetch cur_student into :vSno,vSname,vSclass;
3)exec sql declare cur_student cursor for
select Sno,Sname.Sclass from Student where Sclass='035101';
4)exec sgl close cur student;

A.1234234

B.3124124

C.3214214

D.1324324

---
1. 在嵌入式SQL语言中，宿主语言向SQL语句输入数据，主要用程序变量来实现，为了区别字段名，要求程序变量名前必须加(**D**)符号做标志。

A.;

B..

C.+

D.:

---
1. 事务的隔离性是指(**A**)

A.一个事务内部的操作及使用的数据对并发的其他事务而言是独立的、互不相干的：

B.已提交的事务，其数据将被完全写到永久存储设施上；而对未提交的事务，其对永久
存储设施上的操作将会被恢复，即对永久存储设施上的数据没有任何影响：

C.事务中包括的所有操作要么都做，要么都不做：

D.事务必须是使数据库从一个一致性状态变到另一个一致性状态：

---
1. 事务的原子性是指(**C**)

A.一个事务内部的操作及使用的数据对并发的其他事务而言是独立的、互不相干的：

B.已提交的事务，其数据将被完全写到永久存储设施上；而对未提交的事务，其对永久
存储设施上的操作将会被恢复，即对永久存储设施上的数据没有任何影响：

C.事务中包括的所有操作要么都做，要么都不做：

D.事务必须是使数据库从一个一致性状态变到另一个一致性状态：

---
1. 事务的持久性是指(**B**)

A.一个事务内部的操作及使用的数据对并发的其他事务而言是独立的、互不相干的：

B.已提交的事务，其数据将被完全写到永久存储设施上；而对未提交的事务，其对永久
存储设施上的操作将会被恢复，即对永久存储设施上的数据没有任何影响：

C.事务中包括的所有操作要么都做，要么都不做：

D.事务必须是使数据库从一个一致性状态变到另一个一致性状态：

---
1. 事务是数据库运行的基本单位。如果一个事务执行成功，则全部更新结果将被写到永久存储设施上：如果一个事务执行失败，则对永久存储设施上的数据已做过的更新被恢复原状，好像整个数据库从未有过这些更新，这样保持了数据库处于(**B**)状态。

A.安全性

B.一致性

C.完整性

D.可靠性

---
1. 通过游标对表进行删除或者更新操作时，WHERE CURRENT OF的作用是(**C**)

A.为了提交请求

B.释放游标当前的操作记录

C.允许更新或删除当前游标的记录

D.锁定游标当前的操作记录

---
1. 通过游标操纵数据库，以下说法不正确的是(**D**)

A.在定义游标的查询语句时，必须加上FOR UPDATE子句

B.使用FOR UPDATE子句没有加OF表示通过游标可以修改表中的任何一列

C.FOR UPDATE OF age表示通过游标只能对age属性进行修改

D.使用FOR UPDATE子句表示只能通过游标修改表数据，而不能删除表数据

---
![1741329208883](https://github.com/user-attachments/assets/7ce3eb76-d4bb-4f26-b202-dc74c996673b)

(**D**)

## 10
1. 数据字典是数据库系统中最重要的数据之一，是DBMS记录“表”的定义的数据，当然也
保存着关于“表”的各种运行参数。DBMS中的数据字典可以(**A**)

A.用SQL语言查询

B.由任何用户使用

C.没有

D.由用户创建

---
1. 数据字典通常是由下面哪个组成(**A**)

A.表和视图

B.用户和权限

C.角色和视图

D.用户和表

---
1. 下面关于数据字典的描述中，不正确的是(**A**)

A.数据字典是用户通过SQL-DML(SELECT,UPDATE,DELETE,NSERT)建立和维护
的：

B.数据字典是元数据而不是数据本身

C.数据字典通常也用二维表结构存储相关的数据

D.数据字典是DBMS维护和查询数据库所依赖的重要数据

---
1. 以下关于JDBC的叙述，不正确的是(**A**)

A.JDBC通过一组Java接口实现其目标

B.JDBC使用iava.sql.DriverManager类和java.sgl.Driver类连接到数据库

C.JDBC可做三件事：与数据库建立连接、创建SQL语句对象并执行、返回结果数据集
并提取数据给高级语言程序

D.JDBC是一种用于执行SQL语句的Java API的面向对象的应用程序接口

---
1. 应用程序使用JDBC API访问数据库的具体实施过程有4步：

(1)通过URL得到一个Connection对象，建立数据库连接：

(2)创建一个Statement对象(PreparedStatement或CallableStatement),用来查询或
者修改数据库：

(3)传递一个Driver给DriverManager,加载数据库驱动：

(4)执行查询并返回一个ResultSet,提取数据到应用程序。

若要使用这四步，正确顺序是(**A**)

A.3124

B.3214

C.1234

D.1324

---
1. JDBC核心API中对特定的数据库执行SQL语句的类是(**A**)

A.java.sql.Statement

B.java.sql.PreparedStatement

C.java.sql.CallableStatement

D.java.sql.ResultSet

---
1. 下列关于动态SQL语句的叙述中，不正确的是(**D**)

A.动态SQL语句是SQL标准提供的一种语句运行机制

B.动态SQL语句是指在程序编译时尚未确定，需要在程序执行过程中临时生成的SQL
语句

C.SQL标准引入动态SQL语句的原因是由于静态SQL语句不能提供足够的编程灵活性

D.SQL标准提供的动态SQL语句的执行方式只有立即执行方式

---
1. 下列关于动态SQL、静态SQL的叙述中，不正确的是(**C**)

A.SQL语句在程序中已经按要求写好，体现为一个可执行的SQL语句，把一些参数通过
变量传送给SQL语句即可执行，这是静态SQL

B.SQL语句在程序中动态构造，体现为一个字符串，然后再交给DBMS执行，执行时可
以传递变量，这是动态SQL

C.动态SQL语句的执行方式只能是Prepare-Execute-Using方式，即预编译-传递参量并执
行

D.动态SQL语句是指在程序编译时尚未确定，需要在程序执行过程中临时生成的SQL语
句

---
1. SQLCA和SQLDA是嵌入在C语言中的SQL语言经常使用的两种数据结构。关于SQLCA和SQLDA,下列说法正确的是(**A**)

A,SQLCA是SQL通讯区，记录着SQL语句被DBMS执行后返回的状态信息：SQLDA是
SQL描述区，记求着数据库表等对象的定义信息。

B.SQLCA是SQL通讯区，记录若数据库/表等对象的定义信息：SQLDA是SQL描述区，
记录若SQL语句被DBMS执行后返回的状态信息。

C.SQLCA是SQL描述区，记录若SQL语句被DBMS执行后返回的状态信息；SQLDA是
SQL通讯区，记录若数据库/表等对象的定义信息。

D.SQLCA是SQL描述区，记录着数据库/表等对象的定义信息：SQLDA是SQL描述区，
记录若SQL语句被DBMS执行后返回的状态信息


---
1. 应用程序通过ODBC连接一个数据库服务器的基本步骤如下：

(1)SQLConnect(conn,"aura.bell-labs.com",SQL_NTS,"avi",SQL_NTS,
avipasswd",SQL_NTS);

(2)SQLAllocConnect(env,&conn);

(3){....Do actual work ...}

(4)SQLDisconnect(conn):SQLFreeConnect(conn):SQLFreeEnv(env):

其正确的操作次序是(**A**)

A.2134

B.1234

C.2314

D.1324

---
1. 关于嵌入式SQL语言的思维模式，说法正确的是(**A**)

A.建立数据库连接→声明一个游标（游标与SQL语句绑定）→打开游标（执行SQL语句）→循环地获取一条一条记录（属性与高级语言变量绑定）→关闭游标→可循环地再打开到关
闭游标→断开数据库连接。

B.建立数据库连接->请求分配语句句柄（申请内存空间）→用句柄执行SQL(句柄与SQL语
句绑定)->建立高级语言变量与句柄属性的对应→循环地获取一条一条记录→释放语
句句柄→断开数据库连接。

C.建立数据库连接→创建语句对象（申请内存空间）→用语句对象执行$QL(语句对象与
SQL语句绑定)→返回结果对象→循环地从结果对象获取一条一条记录并提取对象的
属性值传给高级语言变量→释放语句对象→断开数据库连接

D.建立数据库连接→声明一个游标（游标与SQL语句绑定并执行）→打开游标（将执行结果
从磁盘放入内存缓冲区)→循环地获取一条一条记录→关闭游标→可循环地再声明游
标、打开到关闭游标今断开数据库连接。

---
1. 关于下面的思维模式，“建立数据库连接→请求分配语句句柄（申请内存空间）→用句柄执行SQL(句柄与SQL语句绑定)→建立高级语言变量与句柄属性的对应→循环地获取一条一条记录→释放语句句柄→断开数据库连接”。这是关于(**B**)的思维模式。

A.嵌入式SQL语言。

B.ODBC

C.JDBC

D.其他都不是

---
1. 关于下面的思维模式，“建立数据库连接→创建语句对象（申请内存空间）今用语句对象执行SQL(语句对象与SQL语句绑定)→返回结果对象→循环地从结果对象获取一条一条记录并提取对象的属性值传给高级语言变量→释放语句对象→断开数据库连接”。这是关于的思维模式。（**C**）

A.嵌入式SQL语言

B.ODBC

C.JDBC

D.其他都不是

---
1. SQL语句执行后，需要将结果记录集中的属性值，读到高级语言的变量中，那什么时候建立高级语言变量与属性的绑定，下列说法不正确的是(**D**)

A.嵌入式SQL语言：在一条一条地读取记录时(Ftch)建立绑定。

B.ODBC:在开始一条一条地读取记录之前用专门的语句建立绑定。

C.JDBC:一条一条记录的，边绑定，边读取相应的属性值。

D.其他选项说法有不正确的

---
![1741330155103](https://github.com/user-attachments/assets/cb99c3cf-e6ed-436c-9617-a7c76c4e1f56)

(**A**)

---
![1741330211041](https://github.com/user-attachments/assets/61e65cdd-5784-4a2f-9dce-8967c2a27542)

(**C**)
