## 11
1. 如右图所示ER图，“保存”是一个联系，其指向“图书”的基数为(**C**)

![1741401636832](https://github.com/user-attachments/assets/986f5fdf-a151-42c7-89e6-39979d3be3f7)


---
1. 如右图所示ER图，“is Composed of'”是一个联系，下列描述其蕴涵的规则，正确的是(**C**)

![1741401736985](https://github.com/user-attachments/assets/e66f2d6f-e68b-4c15-bd09-eb060aa8c737)

A.一个Item可以由一个或多个其他Item构成；

B.一个Item只能由另一个Item构成；

C.一个Item可由多个其他Item构成，也可以不由任何Item构成；

D.一个Item可以构成至少一个其他的Item;


---
1. 如图所示，这是为民政局开发的婚姻管理系统的E-R图，“婚姻”是一个联系，其指向
“女人”的基数为(**C**)

![1741402034949](https://github.com/user-attachments/assets/ceadba45-2695-4c4c-88a5-3d23821a7d23)

A.0.1;

B.1.1;

C.0.m;

D.1.m;


---
1. 如图所示E-R图，“teaches'”是一个联系，下列描述其蕴涵的规则，正确的是(**B**)

![1741402077774](https://github.com/user-attachments/assets/04361141-a161-4d86-917b-8650195cf9b6)

A.一个Professor可以给多个Class授课，一个Class可以由多个Professor来授课。

B.一个Professor可以给多个Class授课，也可以不授课；一个Class必须有一个Professor来授课；

C.一个Professor可以给多个Class授课，也可以不授课；一个Class可以由多个Professor来授课，也可以不由任何Professor来授课；

D.一个Professor必须给一个Class授课；一个Class可以有多个Professor来授课，也可以没有Professor来授课；

---
1. 如图所示E-R图，“takes”是一个联系，下列描述其蕴涵的规则，正确的是(**D**)

![1741402213485](https://github.com/user-attachments/assets/dc771bb2-723f-4f56-a3e4-3ac97fb3827b)

A.一个student可以选择多个class,也可以一个都不选；一个class可以有多个student来
选，也可以没有studenti选择；

B.一个student至少选择一个class,也可以选择多个；一个class至少有一个student:选择，
也可以有多个student来选；

C.一个student?可以选择多个class,也可以一个都不选；一个class至少有一个student选
择，也可以有多个student:来选；

D.一个student至少选择一个class,也可以选择多个；一个class可以有多个student来选，
也可以没有student选择；

---
1. 关于数据模型与概念模型，下列说法正确的是(**B**)

A.关系模型是概念模型，而E-R模型是数据模型：

B.关系模型是数据模型，而E-R模型是概念模型；

C.网状层次模型是概念模型，而关系模型是数据模型；

D.网状/层次模型是数据模型，而关系模型是概念模型。

---
1. E-R图建模过程中分析实体和联系是很重要的。关于实体和联系，下列说法不正确的是(**D**)

A.实体虽然是指一个个可相互区分的个体，但ER图建模是要寻找这些个体的“型”，而非这些个体本身：

B.实体是可以用重叠量词来形容的，在问题域中不能用重叠量词形容的则不是实体；

C.联系是指一个实体的实例与另一个实体的实例之间可能存在的某种联系：

D.E-R图建模关键是发现实体之间存在什么联系，其重点是发现实体之间联系的度数或
元数。

---
1. 一个“画家”要绘制至少一幅“作品”，而一幅“作品”可由一个“画家”绘制，亦可由
多个“画家”绘制。那正确的E-R图表达是(**D**)

![1741402495973](https://github.com/user-attachments/assets/e4482b63-2d77-4b59-93a0-8690ec65c145)

---
1. 一个“画家”要绘制至少一幅“作品”，而一幅“作品”只能由一个“画家”绘制。那正
确的E-R图表达是(**A**)

![1741402553118](https://github.com/user-attachments/assets/dd812811-4e09-495b-8088-c630aa68a8c0)

![1741402568606](https://github.com/user-attachments/assets/ed20cde1-fdc5-4659-a5ed-fa4ede5dad8e)


---
1. 关于“客户”与“合同”之间的联系，客户可以不签订合同，也可以签订不只一份合同，
而合同只能允许和一个客户签订。则E-R图表达正确的是(**A**)

![1741402623566](https://github.com/user-attachments/assets/fe438714-5773-48a1-8f5e-267984785315)

---
1. 现实世界中经常出现如图所示的结构关系，比如产品结构、组织结构等等，若要为其建立E-R模型。则E-R图表达相对最正确的是（**C**)

![1741402675263](https://github.com/user-attachments/assets/3ce9a4bd-3b1f-4112-b275-8aa5d85f4526)

![1741402690069](https://github.com/user-attachments/assets/bf65c846-78a2-40f8-88cd-b67c85b5ab39)

---
1. 若要用E-R图表达“学生按班级选课”，则E-R图表达相对最正确的是(**A**)

![1741402750179](https://github.com/user-attachments/assets/ddb77f0f-99b6-4aae-94cb-d4e2121661e5)

![1741402761431](https://github.com/user-attachments/assets/fc47e97a-f394-4475-8117-25623ebb0df6)

---
1. 若要为一个浴池开发信息系统，有搓澡工、收银员等，请仔细理解需求，并用E-R图表达需求。则E-R图表达需求，相对最正确的是(**D**)

![1741402855270](https://github.com/user-attachments/assets/0cddba4e-3d9e-4d34-974e-8e54d0b9c3bc)

![1741403356735](https://github.com/user-attachments/assets/369a6b9d-c8e7-4144-8822-b315efa4be68)

![1741403375501](https://github.com/user-attachments/assets/5576d4b2-31ae-4fbf-94fa-d6673c38ee15)

---
1. 关于模型和元模型，下列说法不正确的是(**D**)

A.模型是依据元模型中的抽象概念及其关系，对现实世界进行理解，获得具体概念及其
具体关系所形成的：

B.元模型是对模型的抽象，而模型是对现实世界的抽象：

C.同一元模型，可以产生不同的模型：而同一现实世界，也可以产生不同的模型：

D.相比元模型，模型是由一组抽象概念及其之间关系构成的。
## 12
1. 下列哪些实体不是IDEF1X中的实体。不是IDEF1X中实体的选项为(**C**)

A.独立实体与从属实体

B.相交实体或相关实体

C.类实体与对象实体

D.一般实体与分类实体

---
1. 关于IDEF1X中的联系，下列说法不正确的是(==B==)

A.标定联系和非标定联系都是一对多的联系（含一对一的联系）

B.分类联系就是对实体的实例进行分类，将一个实体的实例分类为若干个实体的实例，
分类实体的属性和被分类实体的属性完全一致

C.不确定联系是多对多的联系，不能直接表达，需要将其转换为一对多的联系进行表达

D.DEF1X图的联系己经通过属性继承和相交实体反映出来了，因此图中实体连线上标
注的联系名字仅起辅助阅读的作用，数据库设计时可以不考虑它

---
1. IDEF1X图中不允许直接表达的联系是(**D**)

A.标定联系

B.非标定联系

C.分类联系

D.不确定联系或非确定联系（即多对多联系）

---
1. 关于IDEF1X中的实体与联系，下列说法不正确的是(**D**)

A.IDEF1X的“实体”将来要转换成关系模式，而其“联系”仅起辅助阅读的作用；

B.IDEF1X是通过“属性继承”在实体中建立了与另一个实体的连接联系（一对一或一对
多的联系)：

C.IDEF1X是通过“相交实体”建立了两个实体之间的多对多联系，因此相交实体本质
上是一种联系。

D.IDEF1X是通过继承另一个实体的关键字属性来建立两个实体之间联系的。被继承的
关键字属性在本实体中作为一般属性还是作为关键字属性，没有什么差别：

---
1. 对于下面IDEF1X图示例，其表达的规则是(**C**)

![1741404068487](https://github.com/user-attachments/assets/20cdd13f-8031-4775-880f-2d01144fe1a2)

A.实体A和实体B之间是一对多的联系，多端实例基数为0到多；

B.实体A和实体B之间是一对多的联系，多端实例基数为1到多

C.实体A和实体B之间是多对一的联系，多端实例基数为0到多

D.实体A和实体B之间是多对一的联系，多端实例基数为1到多

---
1. 下面四个IDEF1X图，完全符合IDEF1X图语法规则的是(**A**)

![1741404238239](https://github.com/user-attachments/assets/a973c09b-dab2-4844-8016-c808040f76ae)

---
1. 下图(a)(b)是IDEF1X图分类联系的表达规则，假设实体B的实例集合与实体C的实例集合的并集记为N,而实体A的实例集合记为M,则关于M和N的关系，说法正确的是(**C**)

![1741404493262](https://github.com/user-attachments/assets/6ffa25ef-074a-4b11-a1b5-7863854d04bd)

A. 图(a)表示M $\supset$ N,图(b)表示M $\supset$ N

B.图(a)表示M=N,图(b)表示M $\supset$ N

C.图(a)表示M $\supset$ N,图(b)表示M=N

D.图(a)表示M=N,图(b)表示M=N

---
1. 关于零部件与产品结构（即零部件构成关系），下列表达正确的IDEF1X图是(**A**)

A.

![Pasted image 20250308113219](https://github.com/user-attachments/assets/67ae41ce-dc9a-4e9f-bb38-854c5ebabc3b)

B.

![Pasted image 20250308113241](https://github.com/user-attachments/assets/eae62e84-e8c8-4af6-bc6e-2e8e36b636f0)

C.

![Pasted image 20250308113250](https://github.com/user-attachments/assets/6753670c-087a-4939-aaa7-0bc5ff939077)

D.

![Pasted image 20250308113305](https://github.com/user-attachments/assets/2d35e3b4-7f50-4d00-b72c-34bb88703a00)

---
1. 下面两个图表达了合同与合同条目之间的关系。下列说法正确的是(**D**)

![1742443914151](https://github.com/user-attachments/assets/5837c186-edeb-42b3-9329-8f5db4dd1532)


A. 图(a)是正确的，图(b)是正确的

B. 图(a)是不正确的，图(b)是正确的

C. 图(a)是正确的，图(b)是不正确的

D. 图(a)是不正确的，图(b)是不正确的

----
1. 表达“图书”与“读者”实体联系的IDEF1X图，相比之下最正确的是(**D**)

A. 

![Pasted image 20250308113513](https://github.com/user-attachments/assets/1ad6509f-459e-45ca-b566-30c7b5192d3c)

B.

![Pasted image 20250308113522](https://github.com/user-attachments/assets/c9203be5-98f7-4244-86e5-cd6957d86f90)

C.

![Pasted image 20250308113534](https://github.com/user-attachments/assets/b99e080b-42fa-4a8a-91aa-cdb4bb48b54c)

D. 

![Pasted image 20250308113543](https://github.com/user-attachments/assets/6da24529-f187-44b0-9719-cd87b1fad99d)

---
1. 在某企业，通常多种物资可以一次性入库，填写一张入库单，则表达“入库单”与“物资”实体联系的IDEF1X图，相比之下最正确的是(注意，图中有意忽略联系的名称)(**D**)

A.

![Pasted image 20250308113708](https://github.com/user-attachments/assets/59bf4705-614e-4d1f-a359-e3c82dbafcf9)

B.

![Pasted image 20250308113725](https://github.com/user-attachments/assets/fa0da70b-db4a-4501-810a-4edc600c6fb2)

C.

![Pasted image 20250308113749](https://github.com/user-attachments/assets/f963b954-c640-4041-bc31-7508952f6c1a)

D.

![Pasted image 20250308113801](https://github.com/user-attachments/assets/46fe2c05-c2a5-4d28-bc54-666ca5d7b5e9)


---
1. 如下图所示为某同学绘制的IDEFX图。该图表达的业务规则是(**C**)

![Pasted image 20250308113839](https://github.com/user-attachments/assets/3a7add07-9b56-43ef-8856-564841646faa)

A. 一个客户可以产生多张订单，一种商品能对应零或多个订单号，不同客户的相同订单

号的订单对应不同种商品

B. 一个客户可以产生多张订单，一种商品仅能对应零或一个订单号，不同客户的相同订

单号的订单对应不同种商品

C. 一个客户可以产生多张订单，一种商品仅能对应零或一个订单号，不同客户的相同订

单号的订单对应同一种商品

D. 一个客户可以产生多张订单，一种商品能对应零或多个订单号，不同客户的相同订单

号的订单对应同一种商品

---
1. 如下图示为同一场景的两种IDEF1X图。关于这两个IDEF1X图，说法正确的是(**B**)

![Pasted image 20250308114338](https://github.com/user-attachments/assets/9852bb98-4728-4176-96f5-78ad1329cebc)

A. 图(a)和图(b)表达的是相同的业务规则；都表示X实体的实例和Y实体的实例的一种组合，在实体Z中能出现多次

B. 图(a)和图(b)表达的是不同的业务规则。图a表达的是X实体的实例和Y实体的实例的
一种组合，在实体Z中仅能出现一次，而图b表达的是X实体的实例和Y实体的实例的一种组合，在实体Z中能出现多次

C. 图(a)和图(b)表达的是不同的业务规则。图a表达的是X实体的实例和Y实体的实例的
一种组合，在实体Z中能出现多次；而图b表达的是X实体的实例和Y实体的实例的一
种组合，在实体Z中仅能出现一次

D. 图(a)和图(b)表达的是相同的业务规则；都表示X实体的实例和Y实体的实例的一种组
合，在实体Z中仅能出现一次

---
1. 若要用IDEF1X表达实体X与实体Y之间的多对多的联系，引入一个相交实体Z。则如果要表达实体X的实例和实体Y的实例的一个组合，可以出现多次的情况，且实体X和实体Y的实例均不能以空值组合出现，IDEF1X图绘制正确的是(**C**)

A.

![Pasted image 20250308114602](https://github.com/user-attachments/assets/2c4c2c43-e9da-4d4b-91cc-f14af1039e92)

B.

![Pasted image 20250308114611](https://github.com/user-attachments/assets/16e15680-e786-4497-ad57-17f33492ed0e)

C.

![Pasted image 20250308114621](https://github.com/user-attachments/assets/39d48569-8c41-40ed-bf88-f99015491858)

D.

![Pasted image 20250308114635](https://github.com/user-attachments/assets/446e10da-2b40-4be9-8aa6-8556f3ea2aec)


## 13
1. 如果采用关系数据库来实现应用，在数据库设计的(**C**)阶段将关系模式进行规范化处理。

A.需求分析

B.物理设计

C.逻辑设计

D.概念设计

---
1. 在关系数据库设计中，逻辑数据库设计阶段完成的是(**C**)的任务。

A.创建E-R图IDEF1x图

B.收集需求和整理理解需求

C.关系模式设计，建立逻辑模型

D.用“Create Table”创建表及其索引

---
1. 关于数据库设计，下列说法正确的是(**B**)

A.若要开发一个信息系统，首先要确定使用哪一个DBMS来进行管理，然后才能进行数
据库设计

B.概念数据库设计需要关注用E-R Diagram的思想来理解需求，而不能仅仅关注绘制E-R
Diagram的图形

C.逻辑数据库设计的关注点是属性、结构和命名的冲突问题，数据库设计的规范性问题
和DBMS的选型问题

D.物理数据库设计仅需要考虑数据量的大小、磁盘空间占用及存储结构等特性，但无关
具体的DBMS
---
![1741405968122](https://github.com/user-attachments/assets/9d4ca886-5397-4a01-8654-5c56b11d85e9)

(**D**)
---
![1741406029628](https://github.com/user-attachments/assets/dd0a57c7-43f4-42de-a5fb-3ee32b2a09cf)

(**C**)
---
![1741406131073](https://github.com/user-attachments/assets/b2bd7174-a739-4cf6-b21b-e6aa4125df0c)

(**B**)

---
1. 如下所示Chen方法表达的E-R图，将其转换为关系模式。不正确的选项是(**C**)

![Pasted image 20250308115706](https://github.com/user-attachments/assets/56aa62c8-cefc-4d54-b64d-ed1d41666775)

A. 学生(学号，姓名，所选课程)

B. 学生(学号，姓名)，选课(姓名，所选课程)

C. 学生(学号，姓名)，选课(学号，所选课程)

D. 学生(学号，所选课程)，选课(姓名，所选课程)

---
1. 如下所示Chen方法表达的E-R图，将其转换为关系模式。不正确的选项是(**D**)

![Pasted image 20250308115920](https://github.com/user-attachments/assets/80fc1c48-2d46-442b-a3ae-5d5c1e6a7d45)

A. 可以如下转换

person（name, street, city）

customer（name, credit-rating）

employee（name, salary）

B. 可以如下转换

person（name, street, city）

customer（name, street, city, credit-rating）

employee（name, street, city, salary）

C. 在一定条件下也可以如下转换

customer（name, street, city, credit-rating）

employee（name, street, city, salary）

D. 在一定条件下也可以如下转换

customer（name, credit-rating）

employee（name, street, city, salary）

---
1. 关于E-R图向关系模式的转换的规则正确的是(==C==)

A.复合属性转换时只能将每个分量属性作为所在实体对应关系的属性

B.一对一联系的转换只能将联系定义为一个新的关系，再将属性设为参与双方的关键字
属性

C.泛化实体与具体化实体在转换时，可以不要泛化实体，而仅将具体化实体转换成关系

D.一对多联系的转换，需将多方参与实体的关键字作为单方参与实体对应关系的属性

---
1. 下列由E-R图向关系模式转换具体实例中，明显不正确的是(注意：关系模式
中带下划线的属性为主键。(**D**)

A. 

![Pasted image 20250308120545](https://github.com/user-attachments/assets/b5dfc4ea-104f-4100-8e9d-09ce9c8f6fae)

B.

![Pasted image 20250308120559](https://github.com/user-attachments/assets/af32f4a7-f9e1-4653-b5be-1e70a0044ba2)

C.

![Pasted image 20250308120609](https://github.com/user-attachments/assets/af1d548a-eea6-42c3-9c2c-ccbe64841bf8)

D.

![Pasted image 20250308120617](https://github.com/user-attachments/assets/ab4e7058-06f8-42c9-bd19-84b8a2ea56b2)
## 14
1.如果X决定Y,且在X决定Y中X没有多余的属性，则X->Y是(**C**)

A.部分函数依赖

B.传递函数依赖

C.完全函数依赖

D.多值依赖

---
1. 在关系模式R(U,F)中，如果XY,存在X的真子集X1,使X1→Y,称函数依赖X→Y为(**B**)

A.平凡函数依赖

B.部分函数依赖

C.完全函数依赖

D.传递函数依赖

---
1. 设关系模式R(A,B,C),函数依赖集F={A→B,C→B),则R的候选键为(**A**)

A.AC

B.ABC

C.AB

D.BC

---
1. 如果X->Y,且Y->Z,则X->Z一定为(**D**)

A.部分函数依赖

B.传递函数依赖

C.完全函数依赖

D.都不正确

---
1. 关系模式R(A1,A2,A3,A4,A5),如果(A1,A2)->A3,(A3,A4)->A5,则R的候选键为(**C**)

A.(A1,A2)

B.(A1,A2,A5)

C.(A1,A2,A4)

D.(A1,A2,A3,A4)

---
1. 关系模式R(A1，A2，A3，A4，A5，A6)，如果A1->(A3，A4)； (A2，A4)->A5；
(A3，A5)->A6，则R的候选键为(**B**)

A.A1

B.(A1,A2)

C.(A1,A2,A4)

D.(A1,A3,A5)


---
1. 关系模式R(A1,A2,A3,A4,A5,A6),如果A1->(A3,A4)；(A2,A4)->A5;
(A3,A5)->A6,则关于R的说法正确的是(**D**)

A.即不存在对候选键的部分函数依赖，又不存在对候选键的传递函数依赖

B.存在对候选键的部分函数依赖，但不存在对候选键的传递函数依赖

C.不存在对候选键的部分函数依赖，但存在对候选键的传递函数依赖

D.既存在对候选键的部分函数依赖，又存在对候选键的传递函数依赖

---
1. 关系模式R(A1,A2,A3,A4,A5,A6)如果A2->(A3,A5)；(A1,A3)->A6;
(A2,A6)->A4,则R的候选键为(**B**)

A.A2

B.(A1,A2)

C.(A1,A3)

D.(A2,A6)

---
1. 已知关系R如下表所示。仅就此表而言，函数依赖全部存在于R中的选项为(**A**)

![1741412421554](https://github.com/user-attachments/assets/c12a41a2-0092-4139-816f-480e14a3af35)


A.(A1,A2)->A4,(A5,A4)->A3

B.A1->A4,A5->A3

C.(A2,A3)->A4,(A4,A5)->A2

D.(A1,A3)->A4,(A3,A5)->A4


----
1. 已知关系R如下表所示。仅就此表而言， R的候选键为(**B**)

![1741412570404](https://github.com/user-attachments/assets/7f7cf49b-b791-4ff0-8492-ab0f9563793d)

A.(A1,A2)

B.(A2,A3)

C.(A1,A2,A4)

D.(A1,A3,A5)

----
1. 已知关系R(A1,A2,A3,A4,A5,A6)函数依赖集F为{(A2,A3)->A4,A3->A6,
(A2,A5)->A1},问(A2,A3)关于F的属性闭包为(**B**)

A.{A2,A3,A4,A5}

B.{A2,A3,A4,A6}

C.{A2,A3,A4,A1}

D.{A2,A3,A4,A5,A1,A6}

---
1. 己知关系R(A,B,C,D,E,F,G),函数依赖集F为{A->B,B->D,AD->EF,AG->C},
问：A关于F的属性闭包为(**C**)

A.(A,B,C,D)

B.(A,B,D,E)

C.(A,B,D,E,F)

D.(A,B,C,D,E,F,G)

---
1. 下列推断不成立的选项是(**C**)

A.如果A->B,B->C,则A->C

B.如果A->B,A->C,则A->BC

C.如果AB->C,则A->C,B->C

D.如果A->C,B->C,则AB->C

----
1. 已知关系R(A,B,C,D,E,F,G),函数依赖集F为{AB->
CF,AD->CE,AG->B,D->C,B->D},问：F的最小覆盖为(**B**)

A.{AB->C,AB->F,AD->C,AD->E,AG->B,B->D,D->C}

B.{AB->F,AD->E,AG->B,D->C,B->D}

C.{AB->F,AD->C,AG->B,D->C,B->D}

D.{A->F,B->F,AD->E,A->B,G->B,D->C,B->D}


----
1. 己知关系R(A,B,C,D,E,F,G),函数依赖集F为{BC->
AE,DC->EF,DG->E,B->CD,D->G},问：F的最小覆盖为(**B**)

A.BC->A,BC->E,DC->E,DC->F,DG->E,B->C,B->D,D->G

B.B->A,B->E,DC->F,D->E,B->C,B->D,D->G

C.B->A,B->E,D->E,B->C,B->D,D->G

D.B->A,B->E,D->F,C->F,D->E,B->C,B->D,D->G

---
1. 己知关系R(A,B,C,D,E,F,G),函数依赖集F为{AD->
EF,CD->FB,F->G,D->F,A->D},问：F的最小覆盖为(**B**)

A.AD->E,AD->F,CD->F,CD->B,F->G,D->F,A->D

B.A->E,CD->B,F->G,D->F,A->D

C.A->E,AD->F,CD->B,F->G,D->F,A->D

D.AD->E,CD->B,F->G,D->F,A->D

---
1. 关于函数依赖集F的最小覆盖，说法正确的是(**A**)

A.F中每个函数依赖的右部都是单个属性

B.F中每个函数依赖的左部都是单个属性

C.F中每个函数依赖的左部和右部都是单一属性

D.其他说法都不正确

---
1. 关于函数依赖集F的最小覆盖，说法不正确的是(**B**)

A.F中每个函数依赖的右部都是单个属性

B.F中每个函数依赖的左部都是单个属性

C.F中每个函数依赖的左部没有多余的属性

D.F中每个函数依赖的右部没有多余的属性

---
1. 已知关系R(A,B,C,D,E,F,G),函数依赖集F为{ADG→EF,CD→F,F→B,
A->D},问：能从F中推导出的函数依赖是(**A**)

A.ADG->E,AG->E

B.D->B,G->E 

C.CD->B,AC->B,CDG->F,FE->CB

D.F->B,FA->D,A->EF

---
1. 已知关系R(A,B,C,D,E,F,G),函数依赖集F为{A→B,B->CDE,AD→G,
CG->F},问：能从F中推导出的函数依赖是(**A**)

A.A->G,A->F

B.C->F,G->F

C.D->G,B->E

D.B->G,C->G
## 15
1. 关系数据库规范化是为了解决关系数据库中(**C**)的问题而引入的。

A.插入问题、删除问题和数据冗余

B.提高查询速度

C.减少数据操作的复杂性

D.保证数据的安全性

---
1. 设有关系模式W(C,P,S,G,T,R),其中各属性的含义是：C课程，P教师，S学生，G成绩，T时间，R教室，根据定义有如下数据依赖集D={C->P,(S,C)→G,(T,R)->C,(T,P)→R,(T，S)→R)。关系模式W的一个候选键是，W的规范化程度最高达到。正确选项为(**D**)

A.(S,C),INF

B.(T,R),3NF

C.(T,P),4NF

D.(T,S),2NF

---
1. 在关系模式R(U,F)中，如果F是最小函数依赖集，则(**D**)

A.R∈2NF

B.R∈3NF

C.R∈BCNF

D.R的规范化程度与F是否最小函数依赖集无关。

---
1. 在关系模式R(U,F)中，R中任何非主属性对候选键完全函数依赖是R∈3NF的(**B**)

A.充分必要条件

B.必要条件

C.充分条件

D.既不充分也不必要条件

---
1. 对关系模式：学生（学号，姓名，课程号，课程名，成绩），说法正确的是(**A**)

A.不满足第2范式

B.满足第2范式但不满足第3范式

C.满足第3范式

D.其他都不对

---
1. 对关系模式：邮编（城市，街道，邮政编码），说法正确的是(**C**)

A.不满足第2范式

B.满足第2范式但不满足第3范式

C.满足第3范式

D.其他都不对

---
1. 一般情况，企业会将从一个供应商处一次所进的多种货物办理一次入库，因此设计了关系模式：入库单（单号，日期，库房，供应商，物品，数量，金额），下列说法正确的是(**A**)

A.不满足第2范式

B.满足第2范式但不满足第3范式

C.满足第3范式

D.其他都不对

---
1. 对连锁商店的管理，设计了关系模式：商店（商店，商品部，商品，商品部经理），下列说法正确的是(**B**)

A.不满足第2范式

B.满足第2范式但不满足第3范式

C.满足第3范式

D.其他都不对

---
1. 对图书管理，己知一种图书只能放在一个房间，可放置在多个书架，一个书架可放置多本图书，一个房间有多个书架，一个房间有一个管理员，请分析关系模式：图书（书号，书名，出版日期，出版社，房间号，书架号，管理员)，说法正确的是(**A**)

A.不满足第2范式

B.满足第2范式但不满足第3范式

C.满足第3范式

D.其他都不对

---
1. 对设备管理，请分析关系模式：设备（设备编号，设备名，生产商编号，生产商名称，生产商地址，配件编号，配件名称，配件价格，设备价格)，说法正确的是(**A**)

A.不满足第2范式

B.满足第2范式但不满足第3范式

C.满足第3范式

D.其他不对

---
1.己知关系模式R(A,B,C),函数依赖集F={B->C,B->A,A->BC}。则关于R,说法正确
的是(**D**)

A.R不满足第2范式

B.R满足第2范式但不满足第3范式

C.R满足第3范式但不满足Boyce-Codd范式

D.R满足Boyce-Codd范式

---
1. 关于关系的F,下列说法不正确的是(**C**)

A.关系模式R(U)中关系的每个分量都是不可分的数据项

B.1NF要求关系中不能有复合属性、多值属性及其组合

C.Star (Name,Address(Street,City)是属于lNF的

D.Star(Name,Address,Street,,City)是属于lNF的

---
1. 关于关系的2NF,下列说法不正确的是(**D**)

A.第二范式消除了非主属性对候选键的部分依赖

B.U中的每个非主属性完全函数依赖于候选键

C.属于2NF的前提是属于1NF

D.属于2NF的也可以不属于1NF

----
1. 已知S#:学号，SN:姓名，SD:班级，CN:课程，G:成绩。下列属于2NF的关系模式是(**B**)

A.R(S#,SN,SD,CN,G)

B.R(S#,SN,SD)

C.R(S#,CN,SD,G)

D.R(S#,CN,SD)

---
1. 己知Sid商店，Pid商品编号，Cid商品名称，Did经营部，Mgr经营部经理，Scale经营部规模。下列属于3NF的关系模式是(**B**)

A.R(Sid,Pid,Cid,Did,Mgr,Scale)

B.R(Sid,Pid,Did)

C.R(Sid,Pid,Cid,Did)

D.R(Sid,Pid,Did,Scale)

1. 根据对应的函数依赖，问：下列关系模式不符合第2范式的是(**C**)

A.邮编（城市，街道，邮政编码）

函数依赖：{城市，街道}->邮政编码；邮政编码->城市

B.学生（学号，系号，系主任）

函数依赖：学号->系号，系号->系主任

C.学生（学号，姓名，班级，课程，成绩）

函数依赖：学号->姓名，学号->班级，{学号，课程}>成绩

D.员工（员工码，姓名，部门，部门经理）

函数依赖：员工码->部门，部门->部门经理

---
1. 关于关系范式，下列叙述中正确的是(**B**)

A.如果关系模式R属于1NF,且R中主属性完全函数依赖于主键，则R属于2NF

B.如果关系模式R属于3NF,则R属于2NF一定成立

C.如果关系模式R属于F,则只要消除了R中非主属性对主键的传递依赖，则R可转换
成2NF

D.如果关系模式R属于F,则只要消除了R中非主属性对主键的部分依赖，则R可转换
成3NF

---
1. 在R(XY)中，如果X→Y,并且对于X的某一个真子集X’,有X’→Y,则。(**C**)

A.Y函数决定X

B.Y对X完全函数依赖

C.X为关系R的超码

D.关系R属于2NF

---
1. 关系数据库中的关系要满足第1范式。给定“部门”关系：部门（部门号，部门名，部门成员，部门总经理)，候选键为“部门号”，则因哪个属性而使它不满足第1范式(**B**)

A.部门总经理

B.部门成员

C.部门名

D.部门号

---
1. 设有关系模式R(A,B,C,D,E,),其函数依赖集为{E→D,C→B,CE→F,B->A},则R最高属于第几范式(**A**)

A.1NF

B.2NF

C.3NF

D.BCNF(Boyce-Codd范式)

---
1. 设有关系模式R(A,B,C,D,E),其函数依赖集为{A→B,CE→A,B→D},则R最高属
于第几范式(**B**)

A.1NF

B.2NF

C.3NF

D.BCNF(Boyce-Codd范式)
## 16
1. 关于模式分解，下列说法正确的是(**D**)

A.一个数据库模式可以任意地分解为两个或多个模式，而其内容和依赖关系均将保持不
变；

B.将一个数据库模式R分解为两个模式R1和R2,则R上的任何关系r都有r=Or(R1)
(Natural-Join)Or(R2):

C.将一个数据库模式R分解为两个模式R1和R2,则R1,R2一定能保证R上的函数依赖关
系；

D.我们可以找出将模式R既保持依赖又能无损连接的分解为两个模式R1和R2的方法

---
1.关于关系的规范化，下列说法正确的是(**B**)

A.对于一个关系模式来说，规范化程度越高越好。

B.满足Boyce-Codd范式的关系模式一定满足第三范式。

C.第一范式要求非主属性完全函数依赖于候选键。

D.当关系模式不满足某一范式时，可将其任意分解为两个关系模式并使每一个关系模式
都满足该范式即可。

---
1. 给定关系模式RU,F),其中U={A1,A2,A3,A4,A5,A6},给定函数依赖集合
F={A1->(A2,A3):A3->A4;(A2,A3)->(A5,A6),A6->A1},有一个分解
=R1(A1,A2,A3,A4),R2(A3,A4,A5,A6)},问该分解(**D**)

A.既具有无损连接性，又保持函数依赖

B.不具有无损连接性，但保持函数依赖

C.具有无损连接性，但不保持函数依赖

D.既不具有无损连接性，又不保持函数依赖

---
1. 给定关系模式R(U,F),其中U={A1,A2,A3,A4,A5,A6},给定函数依赖集合
F=A1->(A2,A3):A3->A4;(A2,A3)->(A5,A6),A5->A1},有一个分解
=R1(A1,A2,A3,A4),R2(A2,A3,A5,A6)},问该分解(**C**)

A.既具有无损连接性，又保持函数依赖

B.不具有无损连接性，但保持函数依赖

C.具有无损连接性，但不保特函数依赖

D.既不具有无损连接性，又不保持函数依赖

---
1. 给定关系模式R(U,F),其中U={A1,A2,A3,A4,A5,A6},给定函数依赖集合
F=A1->(A2,A3):A3->A4:(A2,A3)->(A5,A6),A5->A2},有一个分解
=R1(A1,A2,A3,A4),R2(A2,A3,A5,A6)},问该分解(**A**)

A.既具有无损连接性，又保持函数依赖

B.不具有无损连接性，但保持函数依赖

C.具有无损连接性，但不保持函数依赖

D.既不具有无损连接性，又不保持函数依赖

---
1. 给定关系模式R(U,F),其中U={A1,A2,A3,A4,A5,A6},给定函数依赖集合
F=A1->(A2,A3):A3->A4;(A2,A3)->A5;A6->A3},有一个分解
=R1(A1,A2,A3,A4),R2(A2,A3,A5,A6)},问该分解(**B**)

A.既具有无损连接性，又保持函数依赖

B.不具有无损连接性，但保持函数依赖

C.具有无损连接性，但不保特函数依赖

D.既不具有无损连接性，又不保持函数依赖

---
1. 给定关系模式R(U,F),其中U={A1,A2,A3,A4,A5},给定函数依赖集合
F=A2->A1;A4->A1;A1->A5;(A1,A3)->A2。有一个分解r=
R1(A1,A2,A3,A5),R2(A3,A4),问该分解(**D**)

A.既具有无损连接性，又保持函数依赖

B.不具有无损连接性，但保持函数依赖

C.具有无损连接性，但不保持函数依赖

D.既不具有无损连接性，又不保持函数依赖

---
1. 关系模式R(A1,A2,A3,A4,A5,A6),给定函数依赖集合F={A2->(A3,A5):
(A1,A3)->A6;(A2,A6)->A4},则关于R,既保持依赖又无损连接地分解成第三范式，
分解正确的是(**B**)

A.r={R1(A2,A3,A5),R2(A1,A3,A6),R3(A2,A4,A6)}

B.r={R1(A2,A3,A5),R2(A1,A3,A6),R3(A2,A4,A6),R4(A1,A2)}

C.r={R1(A2,A3,A5),R2(A1,A2,A3,A4,A6)}

D.r={R1(A1,A2,A3,A5),R2(A2,A4,A6)}

---
1. 关系模式R(A1,A2,A3,A4,A5,A6,A7),给定函数依赖集合F={A1->A2;A1->A3:
A3->A4;A3->A5;A5->(A6,A7)}则关于R,既保持依赖又无损连接地分解成第三范式，分
解正确的是(**A**)

A.r={R1(A1,A2,A3),R2(A3,A4,A5),R3(A5,A6,A7)}

B.r={R1(A1,A2,A3,A4,A5),R2(A5,A6,A7)}

C.r={R1(A1,A2,A3),R2(A3,A4,A5,A6,A7)}

D.r={R1(A2,A3,A6,A7),R2(A1,A4,A5)}
