# 17
1. 学习数据库物理存储，首先要理解磁盘的结构及其工作原理。下列说法正确的是(**D**)

A.磁盘是由一组盘面构成，每个盘面又被从内到外刻分成若干个同心圆，被称为道，而
每个滋道又按圆周被划分成若干个扇形区域，被称为扇区。滋盘就是按照“盘面：磁
道：扇区”来确定信息的存储地址的。一次磁盘操作只能读写一个盘面一个磁道的一个
扇区。

B.磁盘的盘面可以围绕主轴做高速旋转，进而可使某一扇区移动到磁头所在位置。一次
盘操作可读写一个磁道的所有信息。

C.磁盘通常有一个机械装置，称为读写臂，读写臂可使磁头沿弦盘的径向运动，使磁头在
内侧磁滋道和外侧磁道之间移动，进而使磁头移动到某一磁道的某一扇区位置。一次磁盘
操作可读写一个盘面的所有信息。

D.一个磁盘的若干盘面可以同时旋转，位于不同盘面上的磁头可以同时移动。一次盘操
作可以一次性读写多个盘面上相同道位置的扇区，即一次性读写多个扇区。

---
1. 关于磁盘的读写问题。下列说法正确的是(**C**)
   
A.盘可以一个存储字一个存储字的读写。

B.磁盘仅可以以一个扇区为单位进行读写。

C.磁盘可以以多个扇区为单位进行读写。

D.其他说法都不正确。


---
1. 关于磁盘的快速读写问题。下列说法不正确的是(**D**)
   
A.将信息分块存储在同一道的连续扇区中，可以缩短盘读写数据的时间。

B.将信息分块存储在不同盘面的相同柱面上，可以缩短盘读写数据的时间。

C.将信息分块存储在多个盘上，多个盘同步工作，可以缩短磁盘读写数据的时间。

D.将信息分块分散在不同柱面上存储，可以缩短磁盘读写数据的时间。


---
1. RAID,独立磁盘冗余阵列，是提高数据读写正确性和速度的重要方法。下列哪一项不是RAID可能采取的技术(**C**)

A.块级拆分，将一个文件的不同块存储在不同磁盘上，保证数据读写的快速性。

B.比特级折分，将一个字节的不同位存储在不同盘上，保证数据读写的快速性。

C.流水线，将数据组织成适宜于流水作业处理的结构，保存在多个盘上，保证数据读
写的快速性。

D.互为校验盘，多个磁盘间互为校验盘，保证数据读写正确性。


---
1. 一个磁盘的基本信息为32个圆盘，64个盘面，每个盘面有65536个磁道，每个道（平均有256个扇区，每个扇区有512个字节，问该磁盘的存储容量为(**B**)。

A. $2^{97}$

B. $2^{39}$

C. $2^{44}$

D. $2^{29}$


---
1. 一个磁盘的基本信息为：磁盘以7200转/min旋转。柱面之间移动磁头组合从启动到停止需要1ms,每移动4000个柱面另加1ms.32个圆盘，64个盘面，每个盘面有65536个磁道，每个磁道（平均）有256个扇区，一个扇区512个字节，一个磁盘块=连续8个扇区的数据传输时间约为0.13毫秒。则读写16KB数据的时间为(**B**)

A.最小时间为10.13毫秒

B.最小时间为11.15毫秒

C.最长时间为10.76毫秒

D.最长时间为52.46毫秒


---
1. 下列说法正确的是(**C**)

A.当数据库经过频繁的增加和删除记录后，数据库查询效率是不会发生变化的，即这种情
况不会影响查询的。

B.数据库以排序文件来组织，每当新增一条记录，都需要移动数据库记录以腾出空间将新
增记录插入到其相应的排序位置。

C.数据库以排序文件来组织，每当新增一条记录，将其写入溢出文件，DBA周期性地执
行数据库命令以将溢出文件并入到排序文件中。

D.建立一个股票交易数据库，应采用排序文件来组织，以提高检索速度。


---
1. 关于数据库的组织与存取方法，下列说法不正确的是(**C**)

A.当数据库是按照排序文件进行组织时，增加一条记录是将其写入溢出文件中，而不是直
接写入排序文件。

B.当对数据更新速度有较高要求时，通常采用无序记录文件即堆文件来组织。

C.堆文件的查询访问速度要远高于排序文件的查询速度。

D.无论是堆文件组织还是排序文件组织，在一段时间后都需要对数据库进行重组操作。


---
1. 数据库重组是(**C**)

A.对数据表的数据项进行调整

B.对数据表的记录进行调整

C.对数据表的物理存储进行调整

D.对数据表的结构进行调整


---
1. 关于数据库物理存储，下面说法正确的是(**B**)

A.DBMS总是把一个“表”存储成一个文件，一个文件仅包含一个表中的数据；

B.DBMS既可以将若干个“表”的数据存储在一个文件中，又可以将一个“表”的数据存
储在多个文件中；

C.DBMS可以将若干个“表”的数据存储在一个文件中，但不可以将一个“表”的数据有
储在多个文件中；

D.DBMS不可以将若干个“表”的数据存储在一个文件中，但可以将一个“表”的数据存
储在多个文件中；



---
1. SQL语言的Create Table语句有三个方面的功能。一方面功能是定义关系模式，关于另外两方面的功能，下面说法正确的是(**D**)

A.定义完整性约束和定义安全性约束；

B.定义完整性约束和定义触发器；

C.定义安全性约束和定义物理存储结构；

D.定义完整性约束和定义物理存储结构；


---
1. 在(**B**)组织结构中，记录通常是以输入顺序存储的。

A.顺序文件

B.堆文件

C.散列文件

D.聚簇文件

---
1. 在(**A**)组织结构中，记录通常是按照某一键值的顺序（升序或降序）存储。

A.顺序文件

B.堆文件

C.散列文件

D.聚簇文件

---
1.如果要将一批记录均匀地存储在个数据块中，应采用(**C**)组织结构。

A.顺序文件

B.堆文件

C.散列文件

D.聚簇文件
# 18
1. 关于素引的下列说法正确的是(**C**)

A.一个主文件上可以建立多个索引，但更新主文件数据时只更新一个索引

B.一个主文件上只能建立一个索引，无论是更新还是查询都利用该索引

C.一个主文件上只能有一个可决定物理存储的索引

D.一个主文件上可以有一个或多个可决定物理存储的索引

---
1. 关于索引的下列说法不正确的是(**D**)

A.索引文件比主文件存储小很多，通常先查索引再找主文件速度会快很多

B.索引文件存在与否不改变主文件的物理存储，所以索引可以随时被删除并重建

C.虽然索引文件存在与否不改变主文件的物理存储，但更新主文件数据时要同步更新所有的索引

D.索引文件增加了存储空间和维护负担，所以当主文件数据量很大时使用索引是效率不高的

---
1. 关于稀疏素引和稠密索引，下列说法正确的是(**C**)

A.如果一个搜索码的值在稀疏索引中不存在，则在主文件中对应该搜索码值的记录也不存
在

B.如果一个搜素码的值在稀疏索引中存在一个，则在主文件中对应该搜索码值的记录也只
存在一个

C.如果一个搜索码的值在稠密索引中不存在，则在主文件中对应该搜索码值的记录也不存
在

D.如果一个搜素码的值在稠密索引中存在一个，则在主文件中对应该搜素码值的记录也只
存在一个

---
1. 关于主索引，下列说法不正确的是(**C**)

A.主索引是对每一个存储块都有一个索引项

B.主索引通常建立在有序主文件的基于主码的排序字段上

C.主索引是关于主码的稠密索引

D.主索引是按索字段值进行排序的一个有序文件

---
1. 数据库主索引是一种(**B**)的索引。

A.对每一记录，都有一个索项

B.对每一存储块有一个索引项

C.对索引字段上的每一个不同值有一个索引项

D.其他都不对

---
1. 关于稠密素引的下列说法正确的是(**D**)

A.稠密索引是对每一个存储块都有一个索引项

B.稠密索引的索引项的个数x与主文件索引字段上的不同值个数y有密切关系，一般而言要
求x≤y

C.主索引通常是关于主码的稠密索引

D.稠密素引通常是按索引字段值进行排序的一个有序文件

---

---
1. 关于索引的下列说法正确的是(**D**)

A.在任何情况下，用索引进行查询都比不用索引进行查询要快

B.执行一条查询语句，当有索引时，DBMS总是首先在索引中查找，然后根据索引中的指
针到主文件中查找

C.索引是DBMS自动建立和维护的，DBA或者用户无需建立也不能建立索引

D.主索引是DBMS自动建立和维护的，关于其他数据项上的索引需要DBA来建立，DBMS
可自动维护DBA建立的索引

---
1. 关于索引的下列说法不正确的是(**C**)

A.主素引是对每一个存储块都有一个索引项

B.稠密索引，对于Tab1e中索引字段的每一个不同值，总是有一个索引项

C.稠密索引，对于Table中的每一个记录，总是有一个索引项

D.稀疏索引是对于Tab1e中的部分记录有索引项

---
1. 关于聚蔟索引和非聚簇索引，下列说法正确的是(**C**)

A.聚簇索引中邻近的记录在主文件中不一定是邻近存储的，聚簇索引中一定不存在重复键
值的索引项

B.聚簇索引中邻近的记录在主文件中一定是邻近存储的，聚簇索引中一定不存在重复键值
的素引项

C.一个主文件只能有一个聚蔟索引文件，但可以有多个非聚簇索引文件

D.一个主文件可以有多个聚簇索引文件，也可以有多个非聚簇索引文件

---
1. 用B+树建立主索引，下列说法正确的是(**A**)

A.叶结点某索引项X的左侧指针，指向键值=X记录所在的主文件存储块

B.非叶结点某索引项X的左侧指针，指向键值=X记录所在的主文件存储块

C.叶结点某索引项X的左侧指针指向键值<X记录所在的主文件存储块

D.非叶结点某索引项X的左侧指针指向键值<X记录所在的主文件存储块；

---
1. 用B+树建立主索引，下列说法正确的是(**D**)

A.叶结点某索引项X的左侧指针，指向键值=X记录所在的索引文件存储块

B.非叶结点某索引项X的左侧指针，指向键值=X记录所在的索引文件存储块

C.叶结点某索引项X的左指针指问键值<=X记录所在的索文件存储块

D.非叶结点某索引项X的左侧指针指向键值<X记录所在的索引文件存储块

---
1. 已知存储块大小为4096字节，在整型属性（一个整型数值占有4个字节）上建立B+树索引，一个指针占有8个字节，则该存储块最多能有个索引项和个指针(**A**)。

A.340,341:

B.339,340:

C.341,342;

D.341,340;

---
1. 已知存储块大小为4096字节，在整型属性（一个整型数值占有4个字节）上建立B树索引，一个指针占有8个字节，则该非叶结点存储块最多能有个索引项和个指针。(**C**)

A.340,341;

B.340,342;

C.204,410;

D.204,408;

---
1. 关于B+树可以建立何种索引，下列说法不正确的是(**B**)

A.用B+树可义建立候选键属性上的稀疏索引，但主文件必须按该属性排序存储

B.用B+树可义建立候选键属性上的稠密索引，但主文件必须按该属性排序存储

C.用B+树可义建立非候选键属性上的稠密索引；主文件可以按该属性排序存储，也可以
不按该属性排序存储

D.用B+树可义建立候选键属性上的稠密索引；主文件可以按该属性排序存储，也可以不
按该属性排序存储

---
1. 关于B+树，下列说法不正确的是(**A**)

A.如果发生合并，则一定会减少索引存储块的数目

B.如果发生合并，则不一定会减少索引存储块的数目

C.如果发生分裂，则一定会增加索引存储块的数目；

D.如果发生分裂与合并，则一定伴随着指针的调整

---
1. 关于B+树，下列说法正确的是(**D**)

A.B+树在任何情况下都可以保证结点中指针的使用率大于等于50%

B.B+树中所有结点的索引项，才能覆盖主文件的完整索引

C.如果用B+树建立主索引，贝B+树中所有结点的索项都包含指向主文件存储块的指针

D.B+树索引的所有叶子结点构成主文件的一个排序索引

---
![1741071990876](https://github.com/user-attachments/assets/50cd5353-0e65-4bdd-a8b3-2f3a8092a0d2)

![1741072010215](https://github.com/user-attachments/assets/3d78398b-7b12-4b71-b7fe-b32a452ed2e1)

C

----
1. 已知一棵B+树，如下图所示。若要在此B+树上删除一个键值为30的素引项，删除完成后的B+树是(**C**)

![1741072266029](https://github.com/user-attachments/assets/f7a21d15-7c09-477b-8ef5-d50a4e911d8e)


---
1. 某同学X欲产生一棵B+树，绘制出了如下图所示的结果。另一位同学Y总结了该图作为B+树存在的问题如下：(1)键值45的非叶结点的素引项不正确，(2)键值13的叶结点的最右指针指向不正确；(3)键值30的非叶结点不应该存在，应被合并到键值45的结点中，(4)键值35的结点应被删除，因为键值30的结点被合并后，不需要了。(5)键值13的叶结点也应该被合并。按照B+树要求，你认为Y同学的说法哪些是正确的。正确的选项是(**C**)

![1741072487530](https://github.com/user-attachments/assets/8d9f93c9-04d9-421e-ae91-f792872129c7)

---
![1741072541014](https://github.com/user-attachments/assets/a9edbcd4-301d-441f-9c40-a71c6c725742)

![1741072559878](https://github.com/user-attachments/assets/6a96f9a2-3d44-46f5-8318-7f222ca88627)

![1741072571366](https://github.com/user-attachments/assets/65040227-29dc-4c0a-b06e-9486013ac403)

A
---
![1741072752054](https://github.com/user-attachments/assets/5af2be93-920c-429f-b4ac-45957ce8913a)

![1741072765791](https://github.com/user-attachments/assets/6cbcc3fd-4440-4103-9872-4cccdc86742c)

![1741072779800](https://github.com/user-attachments/assets/ca1e8366-3141-4577-a331-f3b873b088e9)

D

---
1. 已知一个存储块可存放主文件的5条记录，或存放索引文件的20个索引项。已知主文件有n条记录，则创建稠密素引和稀疏索引各需要的存储块数是__和__(**D**)

A.n,n/20

B.n/5,n20

c.n20,n/5

D.n/20,n/100

---
1. 已知一个存储块可存放主文件的50条记录，或存放索引文件的500个索引项，要求存放主文件数据和存放索引文件数据的存储块最多只能填满80%，已知主文件有n条记录，则创建稠密索引和稀疏索引各需要的存储块数是__和__(**D**)

A.n/50,n/500

B.n/40,n/400

C.n/500,n/25000

D.n/400,n/16000

---
1. 主索引通常确定“表”数据的(**D**)

A.唯一性

B.取值范围

C.逻辑顺序

D.物理顺序
# 19
1. 已知BX为关系X的磁盘块数目，IX为关系X的元组的长度，TX为关系X的元组的数目，b为磁盘块或内存页的大小，M为可用内存页的数目。问：以下算法的适用条件是(**C**)

![1741073508034](https://github.com/user-attachments/assets/f2724f5c-16b1-4ace-9b9f-ac70129f8f62)

A.BR<BS,BS\<M

B.BR>BS,BS\<M

C.BS>BR,BR \<M

D.BS<BR,BR\<M

---
1. 已知BX为关系X的磁盘块数目，IX为关系X的元组的长度，TX为关系X的元组的数目，b为磁盘块或内存页的大小，M为可用内存页的数目，X为分配给X的内存区域。问：不考虑结果关系的存取，以下算法的复杂性是(**C**

![1741073671715](https://github.com/user-attachments/assets/54080a26-3ebd-490f-9854-584ec7d6899d)

A.BRBS +BS

B.(BR+BS )(M-2)+BS

C.BRBS/(M-2)+BS

D.(BR+BS )/(M-2))+BS

---
1. 已知BX为关系X的兹盘块数目，X为关系X的元组的长度，TX为关系X的元组的数目，b为磁盘块或内存页的大小，M为可用内存页的数目，X为分配给X的内存区域。问：关于以下两个算法(a)(b),说法正确的是(**B**)

![1742276066828](https://github.com/user-attachments/assets/5dc5133d-3ea0-4d1e-81e2-f9396f63797c)

A.算法(a)和算法(b)的复杂性是相同的，算法(a)和算法(b)的适用条件是相同的

B.算法(a)和算法(b)的复杂性是相同的，算法(a)和算法(b)的适用条件是不同的

C.算法(a)和算法(b)的复杂性是不同的，算法(a)和算法(b)的适用条件是相同的

D.算法(a)和算法(b)的复杂性是不同的，算法(a)和算法(b)的适用条件是不同的

---
1. 下列关系代数操作，任何时候都能够用一趟算法实现的是(**B**)

A. $\sigma_{\mathrm{F}}(\mathbf{R}),\cup_{\mathrm{s}}$

B. $\sigma_{\mathrm{F}}(R),\cup_{\mathrm{B}}$

C. $\cup_{s},\cup_{B}$

D.其他都不对

---
1. 关于给出的九个关系代数操作： $U_{s},n_{s},-s_{s},U_{B},\cap_{B},-\_{B},\delta(R),\gamma(R),\tau_{(R)}$ 问任何时候都能够用一趟算法实现的操作的个数是(**B**)

A.0

B.1

C.2

D.大于2


---
1. 已知R和S的参数BR=BS=10,000,可用内存页数目为M。若要进行R和S的Theta-连接操作，没有索引可以使用，忽略结果存取的IO次数。问：M分别应是怎样的值，才能使磁盘的I/O次数不超过(1)200.000,(2)25.000,(3)20.000。结果正确的是(**C**)

A.M>560，M>6.000，M>20.000

B.M>500，M>10,000，M>30,000

C.M>530，M>6700,M>10.000

D. M>630, M>4,700, M>15,000

---
1. 下面是一个迭代器实现算法。该算法实现的是操作。(**A**)

![1741074622522](https://github.com/user-attachments/assets/6328d0ac-d95a-433b-9775-cbedc62220fd)

A.RUS

B. R $\cap$ S

C.R-S

D.S-R

---
1. 下面是一个迭代器实现算法。该算法实现的是操作。(**C**)

![1741074856978](https://github.com/user-attachments/assets/68c0848d-3b00-4282-ae50-b0fdb4b4f787)

A.RUS

B.R $\cap$ S

C.R-S

D.S-R

---
1. 下面是一个迭代器实现算法。该算法实现的是操作。(**B**)

![1741074900318](https://github.com/user-attachments/assets/cac0ef41-8602-4122-ad70-6787039277c5)

A.RUS

B.R $\cap$ S

C.R-S

D.S-R


---
1. 假设关系R的元组个数为T(R),元组的大小为I(R),存储块的大小为b,B(R)=T(R)\*(IR)/b。关于表空间扫描算法，下列说法正确的是(**B**)

A.表空间扫指算法的复杂性始终为B(R)

B.表空间扫描算法的复杂性可能为B(R),也可能为T(R)

C.表空间扫描算法的复杂性始终为T(R)

D.其他说法都不正确
---
1. 已知关系R的参数如下：聚簇存储磁盘块数B（R）=1,000，元组数T（R）=20,000，R中属性A的不同值的个数记为V（R，A）=100。R上有基于属性A的排序索引。关于 $\sigma_{A=0(R)}$ ，下列说法正确的是(**A**)

A.如果R是聚簇存储的且不使用索引，则该操作的执行代价为1000个I/O

B.如果不使用索引，则该操作的执行代价为1000个I/0

C.如果R是聚簇存储的且使用索引，则该操作的执行代价为1000个I/O

D.如果R是聚簇存储的且使用索引，则该操作的执行代价平均为100个I/O

---
1. 关于去重复&(R)操作的一趟扫描算法，下列说法不正确的是(**D**)

A.非精确的讲，算法的应用前提是B(R)<=M,其中M为可用内存块数，B(R)为R中数据
所占用的磁盘块数。

B.算法的关键是建立内存数据结构，可以建立敢列结构，也可以建立排序结构，目的是进
行快速比较。

C.算法可以做到只与一个内存块中的数据进行比较，即可判惭出是否有重复。

D.算法需要首先R的所有数据建立内存数据结构，然后才能判断是否有重复的元组存
在。


---
1. 分组聚集操作的一趟扫描算法(**D**)

A.非精确的讲，算法的应用前提是B(R)<=M,其中M为可用内存块数，B(R)为R中数据
所占用的磁盘块数

B.算法的关键是建立内存数据结构，可以建立散列结构，也可以建立排序结构，目的是进
行快速比较

C.算法可以做到一条记录只与一个或少量几个内存块中的数据进行分组聚集计算

D.算法可以边执行边建立内存数据结构，即仅对已处理过的数据建立内存数据结构，便可
进行各个分组的聚集计算
# 20
1. 已知内存共有8块，若要排序有70块的数据集，应如何组织，才能使磁盘读写次数最少。下列方案中磁盘读写次数最少的方案是(**A**)

A.方案I:(1)以8块为一个单位划分子集合，每个子集合进行内排序并存储，形成9个已排
序子集合（其中包含一个仅有6块的子集合），(2)接着在9个子集合中选择3个子集合
(其中包含仅有6块的子集合)，进行一个三路归并，形成一个已排序子集合；(3)再将剩
余5个子集合与刚才归并后形成的子集合，进行一个七路归并，形成最终的已排序集
合。这个方案的磁盘读写次数最少。

B.方案Ⅱ：(1)以7块为一个单位划分子集合，每个子集合进行内排序并存储，形成10个已
排序子集合；(2)接着在10个子集合中任选5个子集合进行一个五路归并，形成一个已排
序子集合；(3)再将剩余5个子集合与刚才归并后形成的子集合，进行一个六路归并，形
成最终的已排序集合。这个方案的磁盘读写次数最少。

C.方案I:(1)以8块为一个单位刻分子集合，每个子集合进行内排序并存储，形成9个已
排序子集合（其中包含一个仅有6块的子集合）；(2)接着在9个子集合中任选七个子集
合进行一个七路归并，形成一个已排序子集合；(3)再将剩余2个子集合与刚才归并后形
成的子集合，进行一个三路归并，形成最终的已排序集合。这个方案的磁盘读写次数最
少。

D.方案IV:(1)以8块为一个单位刻分子集合，每个子集合进行内排序并存储，形成9个已
排序子集合；2)接着在9个子集合中任选5个子集合进行一个五路归并，形成一个已排
序子集合；(3)再将剩余4个子集合与刚才归并后形成的子集合，进行一个五路归并，形
成最终的已排序集合。这个方案的盘读写次数最少
---
1. 已知内存共有100块，若要排序有10000块的数据集，则下列说法正确的是(**B**)

A.该数据集可以在两趟内实现排序，盘读写次数为40000次。

B.该数据集不能在两趟内实现排序，磁盘读写次数为40400次。

C.该数据集可以在两趟内实现排序，盘读写次数为40400次。

D.该数据集不能在两趟内实现排序，盘读写次数为60000次。

---
1. 已知内存共有8块，若要排序有100块的数据集，则给定多路归并算法如下：(1)以8块为一个单位划分子集合，每个子集合进行内排序并存储，形成13个已排序子集合（含一个仅有4块的子集合）；(2)接着在13个子集合中任选7个子集合（包含仅有4块的子集合）进行一个七路归并，形成一个已排序子集合；(3)再将余6个子集合与刚才归并后形成的子集合，进行一个七路归并，形成最终的已排序集合。问：这个方案的磁盘读写次数是(**C**)

A.200

B.400

C.504

D.512


---
1. 关于基于排序的两趟算法，下列说法不正确的是(**D**)

A.基于排序的两趟算法的第一抽都是划分子表并排序。每一个子表应都能装入内存，并进
行排序，然后再存回磁盘。

B.基于排序的两趟算法的第二抽是进行归并，在归并的过程中可以边排序边去重复，归并
完成即去重复作完成。

C.基于排序的两趟算法的第二趟是进行归并，在归并的过程中可以一边排序一边进行分组
并进行聚集计算，归并完成即分组聚集计算操作完成。

D.基于排序的两趟算法的第二趟是进行归并，先归并处理第一个关系的元组，边归并边去
重复，归并处理完成后，再归并处理第二个关系的元组，边归并边去重复，归并处理完
成后即完成两个关系的年合并架作。

---
1. 已知关系R和S关系占用的磁盘块数B(R)=1000,B(S)=1000,已知可用内存页数M=40。采用基于排序的算法，下列说法正确的是(**C**)

A。用一趟算法即可实现R和S的集合并操作。

B.用两趟算法即可实现R和S的集合并操作

C.用一趟算法即可实现R和S的包的并操作。

D.必领用两拖算法才能实现R和S的包的并操作。

---
1. 关于基于散列的两趟算法，下列说法不正确的是(**B**)

A.基于散列的两趟算法的第一趟是散列子表。用某一个散列函数，将具有相同散列值的元
组散列到相同的子表中并存回磁兹盘。

B.基于散列的两趟算法的第二趟是用与第一趟相同的散列函数，将子表再散列到内存的不
同内存块中，在具有相同散列值的所有内存块中去重复，即是在整个关系上去重复。所
有子表处理完成，去重复操作即告完成。

C.基于敢列的两趟算法的第二趟是用与第一趟不同的散列函数，将子表再散列到内存的不
同内存块中，在具有相同散列值的所有内存块中去重复，即是在整个关系上去重复。所
有子表处理完成，去重复操作即告完成。

D.两次散列函数的选择是不同的，第一趟是在大范围上进行散列，将一个大数据集散列成
若干个具有相同散列值的散列子表，第二趟是在小范围上进行散列，将具有某相同散列
值的散列子表（大范围上散列值相等）散列到内存的某一块或几块（小范围上散列值相
等)。

---
1. 基于散列的两趟算法和基于排序的两趟算法，其中第一趟都是划分子表，都要求子表的存储块数要小于可用内存数，以便子表可以一次性装入内存进行处理。关于划分子表，下列说法正确的是(**C**)

A.基于排序的算法总是可以均匀地划分子表（即每个子表的大小都一样，除最后一块外：
基于散列的算法总是可以均匀地划分子表（即每个子表的大小都一样，除最后一块外。

B.基于排序的算法不能保证总是均匀地划分子表；基于散列的算法总是可以均匀地划分子
表（即每个子表的大小都一样，除最后一块外）。

C.基于排序的算法总是可以均匀地划分子表（即每个子表的大小都一样，除最后一块外）；
基于散列的算法不能保证总是均匀地划分子表。

D.基于排序的算法不能保证总是均匀地划分子表；基于散列的算法不能保证总是均匀地划
分子表。

---
1. 关于R与S的并、交、差运算的基于散列的两趟算法，其中第一趟都是划分子表，都要求子表的存储块数要小于可用内存块数，以便子表可以一次性装入内存进行处理。关于划分子表，下列说法正确是(**A**)

A.必须用相同的散列函数将R和S分别散列成若干个子表。

B.必须用不同的散列函数将R和S分别散列成若干个子表。

C.可以用相同的散列函数，也可以用不同的散列函数，将R和S分别散列成若干子表。

D.划分子表根本不用散列函数。

---
1. 关于基于散列的两趟算法和基于排序的两趟算法的基本思想，下列说法正确的是(**B**)

A.排序算法是先划分子表，独立处理子表（第一趟），然后再对各子表进行关联性处理
(第二趟)；散列算法是先划分子表，独立处理子表（第一趟），然后再对各子表进行
关联性处理（第二趟）；

B.排序算法是先划分子表，独立处理子表（第一趟），然后再对各子表进行关联性处理
(第二趟)；散列算法是先从关联性角度处理，形成子表（第一趟），然后再独立处理
每一个子表（第二趟）。

C.排序算法是先从关联性角度处理，形成子表（第一趟），然后再独立处理每一个子表
(第二趟)。散列算法是先划分子表，独立处理子表（第一趟），然后再对各子表进行
关联性处理（第二趟）；

D.排序算法是先从关联性角度处理，形成子表（第一趟），然后再独立处理每一个子表
(第二趟)；散列算法是先从关联性角度处理，形成子表（第一趙），然后再独立处理
每一个子表（第二趟）。


---
1. 关于连接运算R(JOIN on R.A=S.B)S的基于散列的两趟算法，下列说法不正确的是(**C**)

A.必须以相同的散列函数分别散列R和S,形成若干个散列子表。

B.散列过程中，R必须以A属性值作为散列函数的键值，S必须以B属性值作为散列函数的
键值。

C.散列过程中，R必须以A和B属性值作为散列函数的键值，S也必须以A和B属性值作为散
列函数的键值。

D.第二趟处理中，须将R的子表再完整地散列到内存的若干块中，然后再一块一块处理S
对应子表的每一块，以便快速决定可以连接的元组。

---
1. 关于基于散列的两趟算法，下列说法正确的是(==C==)

A.第一趟散列和第二趟散列的目的都是提高数据处理的速度。

B.第一趟散列的目的是提高数据处理的速度，而第二趟散列的目的是使数据子集具有某一
种特性（如具有相同的散列值)。

C.第一趟散列的目的是使数据子集具有某一种特性（如具有相同的散列值，而第二趟散列
的目的是提高数据处理的速度。

D.第一趟散列和第二趟散列的目的都是使数据子集具有某一种特性。
# 21
1. 关于逻辑查询优化和物理查询优化，下列说法正确的是(**B**)

A.逻辑查询优化和物理查询优化都是关系代数操作次序的优化；

B.逻辑查询优化是关系代数操作次序的优化；物理查询优化是关系代数操作实现算法选择
的优化；

C.逻辑查询优化是关系代数操作实现算法选择的优化；物理查询优化是关系代数操作次序
的优化；

D.逻辑查询优化和物理查询优化都是关系代数操作实现算法选择的优化；
---

1. 当发现数据库系统运行性能下降时，可能的原因是(**D**)

A.关于该数据库的统计信息过时了，造成物理实现算法选择决策上的错误。

B.数据库的物理存储结构被破坏了，致使原有存储结构的特性丢失。

C.数据库的物理存储中产生了大量的垃圾，影响了查询实现算法的性能。

D.其他全部都是可能的原因。

---
1. 关于查询优化策略，下列说法不正确的是(**D**)

A.尽可能早的做选择操作，可有效地减少中间结果元组的数目。

B.尽可能早的做投影操作，可有效地减少中间结果所占用的内存块的数目。

C.将笛卡尔积操作与其后的选择操作组合成连接操作，可有效地减少中间结果元组的数
目。

D.笛卡尔积操作的先后次序并不影响中间结果元组的数目，所以查询优化时可不必考虑。

---
1. 已知关系表达式E1和E2满足并相容性，则下列变换不等价的是(**D**)

$A.\:\sigma_{F}(E_{1}\cap E_{2})=\sigma_{F}(E_{1})\cap\sigma_{F}(E_{2})$

$\mathrm{B.~\pi_{A_{1},..,A_{n}}}(E_{1}\cap E_{2})\equiv\pi_{A_{1},..,A_{n}}(E_{1})\cap\pi_{A_{1},...,A_{n}}(E_{2})$

$C.\sigma_F(E_1-E_2)=\sigma_F(E_1)-\sigma_F(E_2)$

$D.\:\pi_{A_1,..,A_n}(E_1-E_2)=\pi_{A_1,..,A_n}(E_1)-\pi_{A_1,..,A_n}(E_2)$


---
1. 关于$\sigma_{F_{1}}(\sigma_{F_{2}}(E))-\sigma_{F_{1}\wedge F_{2}}(E)$,下列说法不正确的(**D**)

A.将左侧公式变换为右侧公式，表示将两趟扫描数据库（左侧），变成一趟扫描数据库
(右侧)

B.将右侧公式变换为左侧公式，表示将复杂条件的选择操作（右侧），变成简单条件的选
择操作（左侧）；

C.在逻辑优化起始，应首先将右侧形式的公式转变为左侧形式的公式；

D.在逻辑优化结束前，应将右侧形式的公式转变为左侧形式的公式。


---
1. 假设A1....An是E1相关的属性，B1,B2..Bm是E2相关的属性。下列哪个变换是正确的(**B**)


![1741142897627](https://github.com/user-attachments/assets/d71eaf80-d65a-45d4-a7be-3bd470ec77ed)


---
1. 已知关系Student(S#,Sname,Sage,Sclass),Course(C#,Cname,Credit,.Cteacher),SC(S#,C#,Score)。给定SQL语句如下："SELECT Score FROM Student,Course,SC WHERE Cname='Database System'and Sname=-‘张伟'andCourse.S#=SC.S#and Course.CSC.C#”(**B**)

![1741143473264](https://github.com/user-attachments/assets/073ae5f2-a67e-448a-a0a9-a1bafa73dbc8)


![1741143503499](https://github.com/user-attachments/assets/fe30e499-4727-42e0-b615-0d7673eb5026)

---
1. 已知关系Student(S#,Sname,Sage,Sclass),Course(C#,Cname,Credit,,Cteacher),SC(S#,C#,Score)。给定SQL语句如下："SELECT Score FROM Student,Course,SC WHERE Cname='Database System'andSname=‘张伟'and Student.S#=SC.S#and Course.C#=SC.C#”请用语法树给出其最终的优化结果，正确的是(**D**)


![1741143696494](https://github.com/user-attachments/assets/9f360187-9780-498c-a5cf-eff9de02b63a)


---
1. 已知如下关系代数表达式，请用语法树给出其最后的优化结果，正确的是(**D**)

$\Pi_{\mathrm{S\#,Sname}}(\sigma_{\mathrm{C \# =001}\wedge\mathrm{Student.S\#}=\mathrm{SC.SH}}(\mathrm{Student}\times\mathrm{SC}))$


![1741145434582](https://github.com/user-attachments/assets/92d44096-faf6-4f38-a03b-f9fb94bc3d44)


---
1. 已知关系Student(S#,Sname,Sage,Sclass),Course(C#,Cname,Credit,Cteacher),SC(S#,C#,Score)。给定SQL语句如下：“SELECT Sname,Cname,Score FROM Student,Course,SC WHERE Cteacher=‘张杰'and Student.S#=SC.S# and Course.C#=SC.C#“请用语法树给出其最后的优化结果，正确的是(**D**)

![1741145729883](https://github.com/user-attachments/assets/8d13aa14-7db9-4e8d-8502-f037520d5142)


![1741145755057](https://github.com/user-attachments/assets/57e7f8da-82de-461d-9695-392131251586)

---
1. 已知关系R和关系S,若要对R(Join on R.Y=S.Y)进行代价估计，则下列正确进行代价估计的是(**A**)

A.若T(R)=10000,T(S)=50000,V(R,Y)=500,V(S,Y)=1000,则连接运算的代价估计为
500.000;

B.若T(R)=10000,T(S)=50000,V(R,Y)=500,V(S,Y)=1000,则连接运算的代价估计为
1.000.000

C.若T(R)=10000,T(S)=50000,VR,Y)=1000,V(S,Y)=500,则连接运算的代价估计为
1.000.000;

D.若T(R)=10000,T(S)=50000,V(R,Y)=2000,V(S,Y)=1000,则连接运算的代价估计为
500.000;

---
1. 已知关系R。T(R)=100,000,V(R.A)=200,V(R,B)=1000,若要对 $S=\sigma_{A=50\:AND\:B<100}(R)$ 进行代价估计，则下列正确进行代价估计的是(**B**)

A.3334

B.167

C.500

D.100

---
1. 已知关系R。T(R)=100,000,V(R,A)=200,V(R,B)=1000,若要对 $S=\sigma_{A=50\:OR\:B<100}(R)$ 进行代价估计，则下列正确进行代价估计的是(**C**)

A.167

B.500

C.33,667

D.50.000

---
1. 已知关系R。T(R)=100,000,V(R,A)=200,V(R,B)=1000,若要对 $S=\sigma_{\mathrm{A=50~OR~(B<100~and~A<50)}}(R)$ 进行代价估计，则下列正确进行代价估计的是(**C**)

A.500

B.1000

c.11.555

D.33.667

---
1. 已知关系R。T(R)=100,000,V(R,A)=200,V(R,B)=1000,若要对 $S=\sigma_{\mathrm{A<100~AND~(B<100~OR~A>50)}}(\mathrm{R})$ 进行代价估计，则下列正确进行代价估计的是(**C**)

A.5.000

B.11,555

c.18.518

D.33.667

# 22
1. 数据库中的封锁机制是(**C**)的主要方法。

A.完整性控制

B.安全性控制

C.并发控制

D.故障恢复控制

---
1. 若事务T对数据R已加X锁，则其它事务对R(**D**)

A.可以加S锁不能加X锁

B.可以加S锁也可以加X锁

C.不能加S锁可以加X锁

D.不能加任何锁

---
1. 若事务T对数据R已加S锁，则其它事务对R(**A**)

A.可以加S锁不能加X锁

B.可以加S锁也可以加X锁

C.不能加S锁可以加X锁

D.不能加任何锁

---
1. 若事务T对数据M已加S锁，在不改变S锁的情况下，则其它事务对数据M(**A**)

A.可以读，但不可以写

B.可以读，可以写

C.不可以读，但可以写

D.不可以读，不可以写

---
1. 下列说法正确的是(**C**)

A.正确的并行调度一定是具有可串行性的调度

B.用于并发控制的两阶段封锁法不会产生死锁现象

C.两阶段封锁法是可串行化的并行调度算法

D.一个调度如果是非冲突可串行化的，那么也一定不是可串行化的

---
1. 下列说法正确的是(****)

A.并发控制只能依靠封锁的方法实现

B.只要对数据项加锁，就能保证数据更新的一致性

C.两阶段封锁法一定能够保证数据更新的一致性

D.两阶段封锁法不会产生死锁现象

---
1. 事务的原子性是指(**A**)

A.事务中包括的所有操作要么都做，要么都不做

B.事务一旦提交，对数据库的改变是永久的

C.一个事务内部的操作及使用的数据对并发的其他事务是隔离的

D.事务必须是使数据库从一个一致性状态变到另一个一致性状态

---
1. T1,T2是两个事务。图(a)(b)(c)给出这两个事务的三种调度，这三种调度会出现什么问题呢，正确的选项是(**A**)

![1741148624367](https://github.com/user-attachments/assets/d77ca897-e5ad-40b0-8e63-c47f7b77c5ec)

A.图(a)的调度会出现“丢失修改”，图b的调度会出现“重复读错误”，图(c)的调度会
出现“脏读”。

B.图(a)的调度会出现“脏读”，图(b)的调度会出现“重复读错误”，图(c)的调度会出现
“丢失修改”。

C.图(a)的调度会出现“重复读错误”，图b的调度会出现“脏读”，图(c)的调度会出现
“丢失修改”。

D.图(a)的调度会出现“丢失修改”，图(b)的调度会出现“脏读”，图(c)的调度会出现
“重复读错误”。

---
1. T1,T2是两个事务。图(a)(b)(c)给出这两个事务的三种调度，这三种调度会出现什么问题呢，正确的选项是(**D**)

![1741163074681](https://github.com/user-attachments/assets/c066e527-ed43-4a80-930a-3bb9b5307806)


A.图(a)的调度会出现“丢失修改”，图(b)的调度会出现“重复读错误”，图(c)的调度会
出现“脏读”。

B.图(a)的调度会出现“脏读”，图(b)的调度会出现“重复读错误”，图(c的调度会出现
“丢失修改”。

C.图(a)的调度会出现“重复读错误”，图(b)的调度会出现“脏读”，图(c)的调度会出现
“丢失修改”。

D.其他都不正确。

---
1. 下列是一段数据库应用程序。问其在执行的过程中，DBMS会产生几个事务，正确的选项是(**C**)

![1741163252236](https://github.com/user-attachments/assets/5dd21006-9fbb-4177-8ff7-b68e04289277)

A.1个事务

B.5个事务

C.<=5个事务

D.>5个事务

---
1. T1,T2是两个事务，图(a)(b)给出这两个事务的两种调度S1,S2,关于S1,S2,说法正确的选项是(**C**)

![1741163343889](https://github.com/user-attachments/assets/ccbd4ff0-8ee7-4046-825f-29241d75e621)

A.S1是可串行化调度，S2是可串行化调度

B.S1是可串行化调度，S2是不可串行化调度

C.S1是不可串行化调度，S2是可串行化调度

D.S1是不可串行化调度，S2是不可串行化调度

---

---
1. T1,T2,T3三个事务，记wi(A)为事务T写数据对象A,ri(A)为事务Ti读数据对象A,一个调度S为“W1(Y):W2(Y):W2(x):W1(x):W3(X):”,问该调度是(**B**)

A.S是冲突可串行化调度，是可串行化调度，是正确的并行调度

B.S不是冲突可串行化调度，但却是可串行化调度，是正确的并行调度

C.S不是冲突可串行化调度，不是可串行化调度，但却是正确的并行调度

D.S不是冲突可串行化调度，不是可串行化调度，不是正确的并行调度


---
1. T1,T2,T3三个事务，记wi(A)为事务Ti写数据对象A,i(A)为事务TT读数据对象A,有两个调度S1和S2为：
S1:r2(A):r1(B);w2(A):r2(B);r3(A);w1(B):w3(A);w2(B)
S2:r2(A):r1(B);w2(A);r3(A);w1(B):w3(A);r2(B);w2(B)
关于S1和S2,说法正确的是(**B**)

A.S1是冲突可串行化调度，S2是冲突可串行化调度

B.S1是非冲突可串行化调度，S2是冲突可串行化调度

C.S1是冲突可串行化调度，S2是非冲突可串行化调度

D.S1是非冲突可串行化调度，S2是非冲突可串行化调度


---
1. T1,T2两个事务，如下图所示。

![1741164372448](https://github.com/user-attachments/assets/0dd256aa-8448-4a70-a289-7e25231e2a4d)

按两段封锁法对其加锁解锁，正确的是(**B**)

![1741164505953](https://github.com/user-attachments/assets/d0aa19c1-6841-496a-96b2-e393c79f584e)

![1741164518867](https://github.com/user-attachments/assets/ac68e603-8cac-4084-a8f1-d0e19601b77f)


----
1. 事务T1、T2如下图所示（注：PRNT(A+B)表示打印账户A和B的总金额）。

![1741164551800](https://github.com/user-attachments/assets/d8d64679-18f3-4e9c-9f8a-accc99acf1d9)

其中事务T1从账号B向账号A转50元钱，事务T1显示账号A和B的总金额，请设计一个服从两段锁协议的加锁解锁方案，使得在并发调度两个事务时，可有效地避免数据的不一致状态。下列方案中不正确的是(**B**)

![1741164591145](https://github.com/user-attachments/assets/e49076f2-1e9d-4cc3-8682-fccd34e6be00)


----
1. 事务T1、T2如下图所示（注：PRNT(A+B)表示打印账户A和B的总金额）。

![1741164747692](https://github.com/user-attachments/assets/a3e6643d-cfc7-4c39-a7ee-b1523aeccbde)

1. 事务T1、T2如下图所示（注：PRNT(A+B)表示打印账户A和B的总金额）。
![[1741164747692.png]]
其中事务T1从账号B向账号A转50元钱，事务T2显示账号A和B的总金额，请设计一个服从两段锁协议的加锁解锁方案，使得在并发调度两个事务时，可有效地避免数据的不一致状态。正确的是(**D**)

![1741164779664](https://github.com/user-attachments/assets/4f5ea1d5-0f72-4def-b35d-7b3bcb0322aa)

---
![1741164866309](https://github.com/user-attachments/assets/2ea71215-6ae5-46d3-a586-2c7e3a07e15d)

A.对该数据对象不可再加任何锁

B.对该数据对象既可再加S锁，又可再加X锁

C.对该数据对象不可再加S锁，但可再加U锁

D.对该数据对象既可再加S锁，又可再加U锁

(**D**)
---
![1741164961535](https://github.com/user-attachments/assets/3ee698f5-7d47-4623-aa18-c73f1e9a58dc)

A.对该数据对象不可再加任何锁

B.对该数据对象既可再加S锁，但不可再加U锁和X锁

C.对该数据对象不可再加S锁，但可再加U锁和X锁

D.对该数据对象既可再加S锁，又可再加U锁和X锁

(**A**)


---
1. 若要使事务的执行是可恢复的，测对有写有求的数据对象加排他锁后，须在(**B**)解锁才能保证可恢复性。

A.该事务完成写操作后

B.该事务提交时刻

C.该程序退出前

D.随时随地


---
1. 基于时间戳的并发控制，不需要锁，但需要进行冲突检测，当发生冲突时需要微销事务并重启事务以解决冲突。已知T1,T2,T3三个事务，记wi(A)为事务T写数据对象Ari(A)为事务Ti读数据对象A。T1,T2,T3三个事务的时间戳为200,150和180，三个事务的操作依下列次序进行中，问被撤消的事务是(**B**)
r1(B);r2(A);r3(C):W1(B):W1(A);w2(C):w3(A);

A.T1被撤销/重启，T2被撤销/重启

B.T2被撤销/重启，T3被撤销/重启

C.T1被撤销/重启，T3被撤销/重启

D.没有被撤销重启的事务

---
1. 如下图中T和U是两个事务，X是数据对象。关于该图，说法正确的是(**D**)

![1741165302022](https://github.com/user-attachments/assets/b8fbf057-5378-4617-a7f8-54e5aa85b191)

A.图(a)图(b)是无冲突的可以被实现，而图(c)图(d)是有冲突的不应被实现。

B.图(b)图(c)是无冲突的可以被实现，而图(a)图(d)是有冲突的不应被实现。

C.图(a)图(c)是无冲突的可以被实现，而图(b)图(d)是有冲突的不应被实现。

D.图(a)图(d)是无冲突的可以被实现，而图(b)图(c)是有冲突的不应被实现。

---
1. 如下图中T和U是两个事务，X是数据对象。关于该图，说法正确的是(**C**)

![1741165437333](https://github.com/user-attachments/assets/025aaa44-a4f9-489e-89fc-77d1854cec71)

A.图(a)图b)是无冲突的可以被实现，而图(c)图(d)是有冲突的不应被实现

B.图(b)图(c)是无冲突的可以被实现，而图(a)图(d)是有冲突的不应被实现

C.图(a)图(c)是无冲突的可以被实现，而图(b)图(d)是有冲突的不应被实现

D.图(a)图(d)是无冲突的可以被实现，而图(b)图(c)是有冲突的不应被实现


---
1. 有效性确认是一种并发控制方法。如下图(a)(b)中T和U是两个事务，X和Y是数据对象。T要进行有效性确认，下列说法正确的是(**B**)

![1741165546047](https://github.com/user-attachments/assets/28424648-99fb-45e4-ab75-08be1b2b9815)

A.图(a)事务T的有效性可以确认；图(b)事务T的有效性可以确认

B.图(a)事务T的有效性可以确认；图(b)事务T的有效性不可以确认

C.图(a)事务T的有效性不可以确认；图(b)事务T的有效性可以确认

D.图(a)事务T的有效性不可以确认；图(b)事务T的有效性不可以确认


---
1. 有效性确认是一种并发控制方法。如下图示意T,U,V,W是四个事务，其所对应的读数据集合RS和写数据集合WS已经分别标注在图中该事务的旁边。A、B、C、D、E、F是数据对象。I、X、O分别表示事务的三个阶段：开始读、有效性确认、完成写。关于T,U,V,W四个事务的有效性确认，下列说法正确的是(**C**)

![1741165899517](https://github.com/user-attachments/assets/4a2909dc-813b-486c-8936-265324f66723)

A.T的有效性可以确认，U的有效性可以确认

B.T的有效性可以确以，U的有效性不可以确认

C.T的有效性不可以确认，U的有效性可以确认

D.T的有效性不可以确认，U的有效性不可以确认


---
1. 关于基于时间戳的并发控制方法（简称TS方法）和基于有效性确以的并发控制方法（简称VA方法）的异同点，下列说法不正确的是(**B**)

A.TS方法和VA方法都是利用时间戳表征事务的启动时刻，表征事务的执行次序

B.TS方法和VA方法都是为每一数据库元素保存一个读时间戳和写时间戳

C.TS方法是比较事务的时间戳与数据库元素的时间戳来判断是否有冲突，而vA方法是通
过比较两个事务的读写数据集合是否有交集来判断是否有冲突

D.TS方法和VA万法都是人撤销事务并重启事务来解决事务之间的冲突

# 23
1. 日志文件是用于记录(**D**)

A.程序运行过程

B.数据操作

C.程序执行结果

D.对数据的所有更新操作


---
1. 下列说法正确的是(**D**)

A.事务故障可以通过运行日志进行恢复

B.介质故障只需将备份恢复到系统中即可实现正确性

C.检查点是指检查发生故障并进行恢复的时刻点

D.检查点是DBMS强制使内存DB Buffer中的内容与介质DB中的内容保特一致的时刻点


---
1. 介质故障的恢复需要(**D**)

A.当前未执行完的事务撒销

B.当前执行完的事务需要按照运行日志记录的次序重做

C.用最新的备份文件替换发生故障的数据库文件

D.以上工作都需要，但需要注意操作的次序。


---
1. 检查点是(**B**)技术中出现的概念。

A.安全性控制

B.故障恢复

C.并发控制

D.完整性控制

---
1. DBMS管理数据库缓冲区有四种策略：No Steal,Steal,No Force,Force。对这四种策略有下面四种解释。
1.内存中的数据最晚在commit的时候写入磁盘：
2.内存中的数据可以一直保留，在commit之后过一段时间再写入磁盘：
3.允许在事务commit之前把内存中的数据写入磁盘：
4.不允许在事务commit之前把内存中的数据写入磁盘；：
则策略与解释有正确对应的是(**D**)

A.Steal:1;Force:2;No Steal:3;No Force:4

B.No Steal:1;No Force:2;Steal:3 Force 4

C.No Steal 1;Steal:2;No Force:3 Force:4

D.Force:1;No Force:2;Steal:3;No Steal:4

---
1. DBMS管理数据库缓冲区有四种策略：No Steal,Steal,No Force,Force。则效率较低但不会出现问题的策略组合是,而效率最高最常用但会出现问题的策略组合是(**B**)

A.No Steal+No Force,Steal Force

B.No Steal+Force,Steal No Force

C.Steal+No Force,No Steal Force

D.Steal+Force,No Steal No Force

---
1. DBMS管理数据库缓冲区有四种策略：No Steal,Steal,No Force,Force。为保证数据库系统故障能够有效地恢复，提出了三种类型的日志：Undo型日志、Redo型日志和Undo/Redo结合型日志。不同策略可以采用不同的日志予以恢复，侧下列说法正确的是(**C**)

A.Steal+Force:不需要任何日志，不需要恢复

B.No Steal+Force:需要Undo.Redo结合型日志进行恢复，不需要Redo型日志

C.No Steal+No Force:需要Redo型日志进行恢复，不需要Undo型日志

D.Steal+-No Force:需要Undo型日志进行恢复，不需要Redo型日志


---
1. 关于Undo型日志和Redo型日志的差别，下列说法正确的是(**C**)

A.Undo型日志仅保留新值，而Redo型日志仅保留旧值

B.Undo型日志是先将Commiti记录写入日志，再将数据写回磁盘OUTPUT,而Redo型日志
是先将数据写回磁盘OUTPUT,再将Commiti记录写入日志

c.Redo型日志是先将Commit记录写入日志，再将数据写回兹盘OUTPUT,而Undo型日志
是先将数据写回磁盘OUTPUT,再将Commit记录写入日志

D.Undo型日志和Redo型日志都是既保留新值，又保留旧值

---
1. 关于用Undo型日志和Redo型日志进行数据库恢复，下列说法正确的是(==D==)

A.用Undo型日志恢复是从日志的起始位置开始恢复，按日志记录的正序处理，直至日志
记录的尾部结束

B.用Redo型日志恢复是从日志的尾部开始恢复，按日志记录的反序处理，直至日志的起
始位置结束

C.用Redo型日志恢复是从日志的起始位置开始恢复，按日志记录的正序处理，直至遇到
第一个检查点为止结束

D.用Undo型日志恢复是从日志的尾部开始恢复，按日志记录的反序处理，直至遇到第一
个检查点为止结束

---
1. 关于用Undo型日志进行数据库恢复，下列说法正确的是(**C**)

A.用Undo型日志恢复是对已完成的事务，将日志记录的新值写回磁盘；而对未完成的事
务，将日志记录的旧值写回磁盘

B.用Undo型日志恢复是对已完成的事务，将日志记录的旧值写回磁盘；而对未完成的事
务，将日志记录的新值写回磁兹盘

c.用Undo型日志恢复是对已完成的事务，跳过；而对未完成的事务，将日志记录的值写
回磁盘

D.用Undo型日志恢复是对已完成的事务，将日志记录的值写回磁盘；而对未完成的事
务，跳过

---
1. 关于用Redo型日志进行数据库恢复，下列说法正确的是(**D**)

A.用Redo型日志恢复是对已完成的事务，将日志记录的新值写回磁盘；而对未完成的事
务，将日志记录的旧值写回磁盘

B.用Redo型日志恢复是对已完成的事务，将日志记录的旧值写回弦盘；而对未完成的事
务，将日志记录的新值写回磁盘

c.用Redo型日志恢复是对已完成的事务，跳过；而对未完成的事务，将日志记录的值写
回磁盘

D.用Redo型日志恢复是对已完成的事务，将日志记录的值写回磁盘；而对未完成的事
务，跳过
