## 函数的阶
$g(n)=\Theta(f(n))$ (同阶)

$g(n)=O(f(n))$ ( $0\leq g(n)\leq cf(n)$ )(低阶)

$g(n)=\Omega(f(n)) $($0{\leq}cf(n){\leq}g(n)$ )(高阶)

$g(n){=}o(f(n))$ ( $0\leq g(n)<f(n)$ )(严格低阶)

>[!NOTE]
>Master定理: $\mathrm{T}(n)=a\mathrm{T}(n/b)+f(n)$\
> $f(n)与n^{log_b^a}比较$\
>哪个大是哪个，一样: $n^{log_b^a}logn$

## 分治算法
解决问题特征：
1. 问题规模缩小之后容易解决
2. 可分解为几个规模较小的相同问题(具有子结构)
3. 子问题可以合并为该问题的解
4. 子问题相互独立


设计过程：
1. 划分
2. 求解
3. 合并

适用算法：
1. 最大值和最小值
2. 大整数乘法
3. 矩阵乘法
4. 快速傅里叶变换
5. 线性时间选择算法
6. 最邻近点对
7. 凸包算法
8. 数据剪除方法

## 动态规划
解决分治算法子问题相互独立效率低

特点：
1. 划分成子问题
2. 将子问题结果保存在表中，用到时直接存取
3. 自底向上计算

使用条件：
1. 优化子结构
2. 重叠子问题
3. 子问题空间小

设计步骤：
分析优化解的结构
递归地定义最优解的代价
自底向上地计算优化解的代价保存之，并获取构造最优解的信息
根据构造最优解的信息构造优化解

解决问题：
1. 最长公共子序列
2. 矩阵链乘法
3. 0/1背包问题
4. 最优二叉搜索树
5. 凸多边形的三角划分

## 贪心算法
求解最优化问题的算法包含一系列步骤
每一步都有一组选择
作出在当前看来最好的选择
希望通过作出局部优化选择达到全局优化选择

产生优化解的条件：
1. 贪心选择性
2. 优化子结构

解决问题：
哈夫曼编码
最小生成树

## 平摊分析

### 基本思想
#### 聚集方法(每个操作的代价)
为每个操作都赋予相同的平摊代价
确定n个操作的上界T(n),每个操作平摊T(n)/n
#### 会计方法(整个操作序列的代价)
不同类型操作赋予不同的平摊代价
某些操作在数据结构的特殊对象上“预付”代价
#### 势能方法(整个操作序列的代价)
不同类型操作赋予不同的平摊代价
“预付”的代价作为整个数据结构的“能量”

## MaxMin方法

### 网络流算法

流网络和流

Ford-Fulkson:算法

推送复标算法

复标前置算法
## 匹配算法
匹配与覆盖

最大二分匹配算法

最大加权二分匹配算法

稳定匹配算法
